/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	const GrowthAnalyser = __webpack_require__(2);
	
	FusionCharts.register('extension', ['private', 'growth-analyser-ext', function () {
	  class GrowthAnalyserExt {
	    constructor () {
	      this.toolbox = FusionCharts.getComponent('api', 'toolbox');
	      this.HorizontalToolbar = this.toolbox.HorizontalToolbar;
	      this.ComponentGroup = this.toolbox.ComponentGroup;
	      this.SymbolStore = this.toolbox.SymbolStore;
	      window.a = this;
	    }
	
	    renderChange () {
	      var chartInstance = this.tsObject.chartInstance,
	        componentStore = chartInstance.apiInstance.getComponentStore(),
	        i = 0;
	      for (i = 0; componentStore.getCanvasByIndex(i); ++i) {
	        componentStore.getCanvasByIndex(i).getComposition().PlotManager.plot();
	      }
	    };
	
	    analyser (mode) {
	      var ga = this.ga || {},
	        store = this.tsObject.apiInstance.getComponentStore(),
	        canvas = store.getCanvasByIndex(0),
	        comp = canvas.getComposition(),
	        ds = ga.ds || comp.dataset,
	        i,
	        idMap = ga.idMap || {},
	        storeAr = ga.storeAr || [],
	        nStoreArr = [],
	        yAxis = canvas.composition.yAxis;
	      // Changing y Axis formattor
	      if (mode === 'reset') {
	        yAxis.getScaleObj().getIntervalObj().getConfig('intervals').major.formatter = function (val) {
	          return val;
	        };
	      } else {
	        yAxis.getScaleObj().getIntervalObj().getConfig('intervals').major.formatter = function (val) {
	          return val + '%';
	        };
	      }
	      // Declaration ends
	      this.ga = ga;
	      if (!ga.storeAr) {
	        store = {};
	        if (!ga.idMap) {
	          ds.forEachSeries(function (a, b, c, series) {
	            store[series.getId()] = series.getOriginalData();
	          });
	          for (i in store) {
	            storeAr.push(store[i]);
	            idMap[i] = storeAr.length - 1;
	            // = store[i].map(function (e) { return 20 * e + (Math.random() * 1000); });
	          }
	          ga.idMap = idMap;
	          ga.ds = ds;
	          ga.storeAr = storeAr;
	          ga.gAnalyser = new GrowthAnalyser(storeAr);
	        }
	      }
	      nStoreArr = ga.gAnalyser.analyse(mode);
	      ds.setDataBySeries(function (series) {
	        if (nStoreArr.length) {
	          series.setOriginalData(nStoreArr[idMap[series.getId()]]);
	        }
	      });
	      comp.impl.update();
	    };
	
	    init (require) {
	      var instance = this;
	      require([
	        'xAxis',
	        'yAxis',
	        'graphics',
	        'chart',
	        'dataset',
	        'PlotManager',
	        'canvasConfig',
	        'MarkerManager',
	        'reactiveModel',
	        'globalReactiveModel',
	        'spaceManagerInstance',
	        'smartLabel',
	        'chartInstance',
	        'extData',
	        'canvasData',
	        function (
	              xAxis,
	              yAxis,
	              graphics,
	              chart,
	              dataset,
	              plotManager,
	              canvasConfig,
	              markerManager,
	              reactiveModel,
	              globalReactiveModel,
	              spaceManagerInstance,
	              smartLabel,
	              chartInstance,
	              extData,
	              canvasData) {
	          instance.xAxis = xAxis;
	          instance.yAxis = yAxis;
	          instance.graphics = graphics;
	          instance.chart = chart;
	          instance.dataset = dataset;
	          instance.plotManager = plotManager;
	          instance.markerManager = markerManager;
	          instance.canvasConfig = canvasConfig;
	          instance.reactiveModel = reactiveModel;
	          instance.globalReactiveModel = globalReactiveModel;
	          instance.spaceManagerInstance = spaceManagerInstance;
	          instance.smartLabel = smartLabel;
	          instance.chartInstance = chartInstance;
	          instance.canvasData = canvasData;
	          instance.extData = extData;
	        }
	      ]);
	      //  console.log(instance.extData);
	      this.spaceManagerInstance = instance.spaceManagerInstance;
	      this.globalReactiveModel = instance.globalReactiveModel;
	      this.tsObject = instance.chartInstance;
	      this.startDt = instance.globalReactiveModel.model['x-axis-visible-range-start'];
	      this.endDt = instance.globalReactiveModel.model['x-axis-visible-range-end'];
	      this.startDataset = instance.globalReactiveModel.model['x-axis-absolute-range-start'];
	      this.endDataset = instance.globalReactiveModel.model['x-axis-absolute-range-end'];
	      this.toolbars = [];
	      this.measurement = {};
	      this.toolbars.push(this.createToolbar());
	      return this;
	    };
	
	    createToolbar () {
	      var toolbar,
	        group,
	        self = this,
	        contextMenu,
	        contextArray = [],
	        gaOptionsObj = {},
	        popup,
	        paper = this.graphics.paper,
	        chartContainer = this.graphics.container,
	        subCatStyle = {
	          'font-size': '12px',
	          'color': '#4b4b4b',
	          'font-family': '"Lucida Grande", Sans-serif'
	        },
	        catStyle = {
	          'font-size': '13px',
	          'color': '#4b4b4b',
	          'font-family': '"Lucida Grande", Sans-serif',
	          'fontWeight': 'bold'
	        };
	
	      toolbar = new this.HorizontalToolbar({
	        paper: this.graphics.paper,
	        chart: this.chart,
	        smartLabel: this.smartLabel,
	        chartContainer: this.graphics.container
	      });
	
	      toolbar.setConfig({
	        fill: '#fff',
	        borderThickness: 0
	      });
	
	      group = new this.toolbox.ComponentGroup({
	        paper: this.graphics.paper,
	        chart: this.chart,
	        smartLabel: this.smartLabel,
	        chartContainer: this.graphics.container
	      });
	
	      group.setConfig({
	        fill: '#fff',
	        borderThickness: 0
	      });
	
	      gaOptionsObj = {
	        'First Index': {position: 0},
	        'Previous Index': {relposition: -1},
	        'Specific Value': {
	          'submenu': true,
	          'Minimum': 'Minimum',
	          'Maximum': 'Maximum',
	          'Mean': 'Mean',
	          'Median': 'Median',
	          'Standard Deviation': 'Standard Deviation',
	          'Custom Value...': function () {
	            popup((val) => self.analyser(val));
	          }
	        }
	      };
	
	      contextMenu = new this.toolbox.SymbolWithContext('ContextIcon', {
	        paper: this.graphics.paper,
	        chart: this.chart,
	        smartLabel: this.smartLabel,
	        chartContainer: this.graphics.container
	      }, {
	        width: 24,
	        height: 24,
	        position: 'right',
	        stroke: '#ced5d4',
	        strokeWidth: '1',
	        radius: '1',
	        symbolStroke: '#696969',
	        symbolStrokeWidth: '2'
	      });
	
	      contextArray.push({
	        'Growth Analyser': {
	          style: catStyle
	        }
	      });
	      popup = function (callback) {
	        var box,
	          header,
	          style = {
	            fontSize: 10 + 'px',
	            lineHeight: 15 + 'px',
	            'font-family': '"Lucida Grande", Sans-serif',
	            stroke: '#676767',
	            'stroke-width': '2'
	          },
	          headerWidth = 180,
	          headerText,
	          cross,
	          inputField,
	          applyButton,
	          x = (self.chart.width * 0.47) - 90,
	          y = self.chart.height / 2 - 40;
	
	        box = paper.html('div', {
	          fill: '#f7f7f7',
	          x: x,
	          y: y,
	          width: 180,
	          height: 80
	        }, style, chartContainer);
	
	        header = paper.html('div', {
	          fill: '#e8e8e8',
	          width: headerWidth,
	          height: 20
	        }, style, box);
	
	        headerText = paper.html('div', {
	          fill: 'transparent',
	          width: headerWidth * 0.6,
	          height: 20,
	          x: 10,
	          y: 2
	        }, style, header);
	
	        headerText.attr({
	          text: 'Provide value'
	        });
	
	        cross = paper.html('div', {
	          fill: 'transparent',
	          width: 10,
	          height: 10,
	          position: 'relative',
	          float: 'right',
	          text: 'X',
	          cursor: 'pointer'
	        }, style, header);
	
	        cross.on('click', function () {
	          box.hide();
	        });
	
	        inputField = paper.html('input', {
	          width: 100,
	          height: 20,
	          x: 10,
	          y: 30
	        }, style, box);
	
	        applyButton = paper.html('div', {
	          width: 50,
	          height: 20,
	          x: 120,
	          y: 30,
	          fill: '#555555'
	        }, {
	          fontSize: 10 + 'px',
	          lineHeight: 15 + 'px',
	          'font-family': '"Lucida Grande", Sans-serif',
	          fill: '#eaeaea',
	          color: '#eaeaea',
	          stroke: '#eaeaea',
	          cursor: 'pointer'
	        }, box);
	
	        function applyValue () {
	          box.hide();
	          callback(inputField.val());
	        }
	        applyButton.on('click', () => {
	          applyValue();
	        });
	        inputField.on('keyup', (e) => {
	          if (e.keyCode === 13) {
	            applyValue();
	          }
	        });
	        applyButton.attr({
	          text: 'Apply'
	        });
	        inputField.element.focus();
	        function inputFieldNumberHandler () {
	          inputField.element.value = inputField.element.value.replace(/[^\d.-]/g, '');
	        }
	        inputField.element.addEventListener('keyup', inputFieldNumberHandler);
	        cross.element.style['position'] = 'relative';
	        cross.element.style['backgroundColor'] = '#d2d2d2';
	        cross.element.style['border'] = '2px solid #cbcbcb';
	        cross.element.style['padding'] = '0px 0px 3.5px 2px';
	        cross.element.style['color'] = '#8c8c8c';
	        cross.element.style['margin'] = '1px 2px';
	        cross.element.style['float'] = 'right';
	        inputField.element.style['marginTop'] = '8px';
	        inputField.element.style['border'] = '2px solid #dadbda';
	        applyButton.element.style['marginTop'] = '8px';
	        box.element.style['border'] = '1px solid #d4d2d3';
	        header.element.style['border'] = '1px solid #d4d2d3';
	        header.element.style['width'] = '179px';
	        headerText.element.style['fontSize'] = '11.5px';
	        headerText.element.style['marginTop'] = '0.5px';
	        headerText.element.style['color'] = '#676767';
	        header.element.style['font-family'] = '"Lucida Grande", Sans-serif';
	        applyButton.element.style['textAlign'] = 'center';
	        applyButton.element.style['fontSize'] = '11px';
	        applyButton.element.style['paddingTop'] = '3px';
	        applyButton.element.style['borderRadius'] = '3px';
	        applyButton.element.style['color'] = '#e4e4e4';
	      };
	
	      for (let i in gaOptionsObj) {
	        let key,
	          obj = {},
	          subObj = {};
	        if (!gaOptionsObj[i].submenu) {
	          key = '&nbsp; &nbsp; ' + i;
	          obj[key] = {};
	          obj[key] = {
	            style: subCatStyle,
	            handler: function () {
	              self.analyser(gaOptionsObj[i]);
	            },
	            action: 'click'
	          };
	        } else {
	          key = '&#9666&nbsp; ' + i;
	          obj[key] = {};
	          obj[key].action = 'click';
	          obj[key].style = subCatStyle;
	          obj[key].handler = [];
	          for (let j in gaOptionsObj[i]) {
	            let subMenuName = j,
	              subMenuValue = gaOptionsObj[i][j];
	            if (j === 'submenu') {
	              continue;
	            }
	            subObj = {};
	            subObj['&nbsp;' + subMenuName] = {};
	            subObj['&nbsp;' + subMenuName].handler = function () {
	              if (typeof subMenuValue === 'function') {
	                subMenuValue();
	              } else {
	                self.analyser(subMenuValue);
	              }
	            };
	            subObj['&nbsp;' + subMenuName].action = 'click';
	            subObj['&nbsp;' + subMenuName].style = subCatStyle;
	            obj[key].handler.push(subObj);
	            if (j.indexOf('Custom') === -1) {
	              obj[key].handler.push({
	                '': {
	                  style: {
	                    backgroundColor: '#d5d2d2',
	                    height: '1px',
	                    margin: '1px',
	                    padding: '0px'
	                  }
	                }
	              });
	            }
	          }
	        }
	        contextArray.push(obj);
	        contextArray.push({
	          '': {
	            style: {
	              backgroundColor: '#d5d2d2',
	              height: '1px',
	              margin: '1px',
	              padding: '0px'
	            }
	          }
	        });
	      }
	
	      contextArray.push({
	        '&nbsp; &nbsp; Reset View': {
	          handler: function () {
	            self.analyser('reset');
	          },
	          action: 'click',
	          style: subCatStyle
	        }
	      });
	
	      contextMenu.appendAsList(contextArray);
	
	      this.SymbolStore.register('ContextIcon', function (posx, posy, rad) {
	        var x = posx,
	          y = posy,
	          r = rad * 2,
	          space = Math.round(r / 4),
	          halfWidth = Math.round(r / 2) * 0.7,
	          startX = (x - halfWidth),
	          endX = (x + halfWidth),
	          startY = (y + space),
	          endY = (y - space);
	        return ['M', startX, y, 'L', endX, y, 'M', startX, startY, 'L', endX, startY, 'M', startX, endY, 'L', endX, endY];
	      });
	
	      group.addSymbol(contextMenu);
	      toolbar.addComponent(group);
	      return toolbar;
	    };
	
	    getLogicalSpace (availableWidth, availableHeight) {
	      availableWidth /= 2;
	      var logicalSpace,
	        width = 0,
	        height = 0,
	        i,
	        ln;
	
	      for (i = 0, ln = this.toolbars.length; i < ln; i++) {
	        logicalSpace = this.toolbars[i].getLogicalSpace(availableWidth, availableHeight);
	        width = Math.max(logicalSpace.width, width);
	        height += logicalSpace.height;
	        this.toolbars[i].width = logicalSpace.width;
	        this.toolbars[i].height = logicalSpace.height;
	      }
	      height += this.padding;
	      return {
	        width: width > availableWidth ? 0 : width,
	        height: height > availableHeight ? 0 : height
	      };
	    };
	
	    placeInCanvas () {
	      var self = this;
	      self.padding = 5;
	      self.spaceManagerInstance.add([{
	        name: function () {
	          return 'ToolBoxExt';
	        },
	        ref: function (obj) {
	          return obj['0'];
	        },
	        self: function () {
	          return self;
	        },
	        priority: function () {
	          return 2;
	        },
	        layout: function (obj) {
	          return obj.inline;
	        },
	        orientation: [{
	          type: function (obj) {
	            return obj.horizontal;
	          },
	          position: [{
	            type: function (obj) {
	              return obj.top;
	            },
	            alignment: [{
	              type: function (obj) {
	                return obj.right;
	              },
	              dimensions: [function () {
	                var parent = this.getParentComponentGroup();
	                return self.getLogicalSpace(parent.getWidth(), parent.getHeight());
	              }]
	            }]
	          }]
	        }]
	      }]);
	    };
	
	    setDrawingConfiguration (x, y, width, height, group) {
	      var mes = this.measurement;
	      mes.x = x;
	      mes.y = y;
	      mes.width = width;
	      mes.height = height;
	
	      this.parentGroup = group;
	
	      return this;
	    };
	
	    draw (x, y, width, height, group) {
	      var measurement = this.measurement,
	        toolbars = this.toolbars,
	        ln,
	        i,
	        toolbar;
	      x = x === undefined ? measurement.x : x;
	      y = y === undefined ? measurement.y : y;
	      width = width === undefined ? measurement.width : width;
	      height = height === undefined ? measurement.height : height;
	      group = group === undefined ? this.parentGroup : group;
	      if (width && height) {
	        for (i = 0, ln = toolbars.length; i < ln; i++) {
	          toolbar = toolbars[i];
	          toolbar.draw(x, y);
	        }
	      }
	    };
	  };
	  FusionCharts.registerComponent('extensions', 'growth-analyser-ext', GrowthAnalyserExt);
	}]);


/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';
	class GrowthAnalyser {
	  constructor (data) {
	    this.data = data.map((a) => {
	      return a.map((b) => { return b; });
	    });
	    this.Formulae = Formulae;
	  }
	  analyse (mode) {
	    let i = 0,
	      ii = 0,
	      j = 0,
	      jj = 0,
	      num = 0,
	      checkArr = [],
	      checkNum = 0,
	      dataAr = this.data,
	      nDataAr = [],
	      tempAr = [],
	      temp = 0;
	    if (typeof mode === 'string' && mode.toLowerCase() === 'reset') {
	      return dataAr.map((a) => {
	        return a.map((b) => { return b; });
	      });
	    } else if (!isNaN(mode)) { // Handling a number
	      checkNum = +mode;
	      for (i = 0, ii = dataAr.length; i < ii; ++i) {
	        tempAr = [];
	        for (j = 0, jj = dataAr[i].length; j < jj; ++j) {
	          num = dataAr[i][j];
	          tempAr.push(100 * (num - checkNum) / checkNum);
	        }
	        nDataAr.push(tempAr);
	      }
	    } else if (typeof mode === 'string') {
	      mode = this.Formulae[mode];
	      for (i = 0, ii = dataAr.length; i < ii; ++i) {
	        tempAr = [];
	        checkNum = mode(dataAr[i]);
	        for (j = 0, jj = dataAr[i].length; j < jj; ++j) {
	          num = dataAr[i][j];
	          if (checkNum === 0) {
	            temp = undefined;
	          } else {
	            temp = 100 * (num - checkNum) / checkNum;
	          }
	          tempAr.push(temp);
	        }
	        nDataAr.push(tempAr);
	      }
	    } else if (!isNaN(mode.relposition)) {
	      mode = mode.relposition;
	      for (i = 0, ii = dataAr.length; i < ii; ++i) {
	        tempAr = [];
	        for (j = 0, jj = dataAr[i].length; j < jj; ++j) {
	          num = dataAr[i][j];
	          if (j + mode >= 0 && j + mode < jj) {
	            checkNum = dataAr[i][j + mode];
	          } else {
	            checkNum = num;
	          }
	          tempAr.push(100 * (num - checkNum) / checkNum);
	        }
	        nDataAr.push(tempAr);
	      }
	    } else if (!isNaN(mode.position) || typeof mode.position === 'string') {
	      mode = mode.position;
	      for (i = 0, ii = dataAr.length; i < ii; ++i) {
	        tempAr = [];
	        for (j = 0, jj = dataAr[i].length; j < jj; ++j) {
	          num = dataAr[i][j];
	          if (mode === 'last') {
	            checkNum = dataAr[i][jj - 1];
	          } else if (mode === 'mid') {
	            checkNum = dataAr[i][jj / 2];
	          } else if (mode >= 0 && mode < jj) {
	            checkNum = dataAr[i][mode];
	          } else {
	            checkNum = num;
	          }
	          tempAr.push(100 * (num - checkNum) / checkNum);
	        }
	        nDataAr.push(tempAr);
	      }
	    } else if (!isNaN(mode.reldatasetposition)) {
	      mode = mode.reldatasetposition;
	      for (i = 0, ii = dataAr.length; i < ii; ++i) {
	        tempAr = [];
	        if (i + mode >= 0 && i + mode < ii) {
	          checkArr = dataAr[i + mode];
	        } else {
	          checkArr = dataAr[i];
	        }
	        for (j = 0, jj = dataAr[i].length; j < jj; ++j) {
	          checkNum = checkArr[j];
	          num = dataAr[i][j];
	          tempAr.push(100 * (num - checkNum) / num);
	        }
	        nDataAr.push(tempAr);
	      }
	    }
	    for (i = 0, ii = nDataAr.length; i < ii; ++i) {
	      for (j = 0, jj = nDataAr[i].length; j < jj; ++j) {
	        if (!Number.isFinite(nDataAr[i][j])) {
	          nDataAr[i][j] = null;
	        }
	      }
	    }
	    var roundToTwo = (num) => {
	      return +(Math.round(num + 'e+2') + 'e-2');
	    };
	    // Rounding values
	    for (i = 0, ii = nDataAr.length; i < ii; ++i) {
	      for (j = 0, jj = nDataAr[i].length; j < jj; ++j) {
	        nDataAr[i][j] = roundToTwo(nDataAr[i][j]);
	      }
	    }
	    for (i = nDataAr.length; i--;) {
	      for (j = nDataAr[i].length; j--;) {
	        temp = parseInt(nDataAr[i][j] * 100);
	        nDataAr[i][j] = temp / 100;
	      }
	    }
	    return nDataAr;
	  }
	}
	
	var Formulae = {
	  Minimum: (arr) => {
	    return arr.reduce((a, b) => {
	      return a > b ? b : a;
	    });
	  },
	  Maximum: (arr) => {
	    return arr.reduce((a, b) => {
	      return a < b ? b : a;
	    });
	  },
	  Mean: (arr) => {
	    return arr.reduce((a, b) => {
	      return a + b;
	    }) / arr.length;
	  },
	  Median: (arr) => {
	    return arr.map((a) => a).sort((a, b) => { return a - b; })[arr.length / 2];
	  },
	  'Standard Deviation': (values) => {
	    function average (data) {
	      var sum, avg;
	      sum = data.reduce(function (sum, value) {
	        return sum + value;
	      }, 0);
	
	      avg = sum / data.length;
	      return avg;
	    }
	    var avg = 0,
	      squareDiffs = 0,
	      sqrDiff = 0,
	      avgSquareDiff = 0,
	      stdDev = 0,
	      diff = 0;
	    avg = average(values);
	    squareDiffs = values.map(function (value) {
	      diff = value - avg;
	      sqrDiff = diff * diff;
	      return sqrDiff;
	    });
	    avgSquareDiff = average(squareDiffs);
	    stdDev = Math.sqrt(avgSquareDiff);
	    return stdDev;
	  }
	};
	
	module.exports = GrowthAnalyser;
	


/***/ }
/******/ ]);

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMmEzNjQzMmEwYjY0ZDEzNDA5NWYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ3Jvd3RoYW5hbHlzZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdENBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixvQ0FBb0M7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDZDQUE0Qyx3Q0FBd0MsRUFBRTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBLHlCQUF3QixZQUFZO0FBQ3BDLDRCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7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QUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJncm93dGgtYW5hbHlzZXItZXM2Lm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDJhMzY0MzJhMGI2NGQxMzQwOTVmIiwiY29uc3QgR3Jvd3RoQW5hbHlzZXIgPSByZXF1aXJlKCcuL2dyb3d0aGFuYWx5c2VyJyk7XG5cbkZ1c2lvbkNoYXJ0cy5yZWdpc3RlcignZXh0ZW5zaW9uJywgWydwcml2YXRlJywgJ2dyb3d0aC1hbmFseXNlci1leHQnLCBmdW5jdGlvbiAoKSB7XG4gIGNsYXNzIEdyb3d0aEFuYWx5c2VyRXh0IHtcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICB0aGlzLnRvb2xib3ggPSBGdXNpb25DaGFydHMuZ2V0Q29tcG9uZW50KCdhcGknLCAndG9vbGJveCcpO1xuICAgICAgdGhpcy5Ib3Jpem9udGFsVG9vbGJhciA9IHRoaXMudG9vbGJveC5Ib3Jpem9udGFsVG9vbGJhcjtcbiAgICAgIHRoaXMuQ29tcG9uZW50R3JvdXAgPSB0aGlzLnRvb2xib3guQ29tcG9uZW50R3JvdXA7XG4gICAgICB0aGlzLlN5bWJvbFN0b3JlID0gdGhpcy50b29sYm94LlN5bWJvbFN0b3JlO1xuICAgICAgd2luZG93LmEgPSB0aGlzO1xuICAgIH1cblxuICAgIHJlbmRlckNoYW5nZSAoKSB7XG4gICAgICB2YXIgY2hhcnRJbnN0YW5jZSA9IHRoaXMudHNPYmplY3QuY2hhcnRJbnN0YW5jZSxcbiAgICAgICAgY29tcG9uZW50U3RvcmUgPSBjaGFydEluc3RhbmNlLmFwaUluc3RhbmNlLmdldENvbXBvbmVudFN0b3JlKCksXG4gICAgICAgIGkgPSAwO1xuICAgICAgZm9yIChpID0gMDsgY29tcG9uZW50U3RvcmUuZ2V0Q2FudmFzQnlJbmRleChpKTsgKytpKSB7XG4gICAgICAgIGNvbXBvbmVudFN0b3JlLmdldENhbnZhc0J5SW5kZXgoaSkuZ2V0Q29tcG9zaXRpb24oKS5QbG90TWFuYWdlci5wbG90KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGFuYWx5c2VyIChtb2RlKSB7XG4gICAgICB2YXIgZ2EgPSB0aGlzLmdhIHx8IHt9LFxuICAgICAgICBzdG9yZSA9IHRoaXMudHNPYmplY3QuYXBpSW5zdGFuY2UuZ2V0Q29tcG9uZW50U3RvcmUoKSxcbiAgICAgICAgY2FudmFzID0gc3RvcmUuZ2V0Q2FudmFzQnlJbmRleCgwKSxcbiAgICAgICAgY29tcCA9IGNhbnZhcy5nZXRDb21wb3NpdGlvbigpLFxuICAgICAgICBkcyA9IGdhLmRzIHx8IGNvbXAuZGF0YXNldCxcbiAgICAgICAgaSxcbiAgICAgICAgaWRNYXAgPSBnYS5pZE1hcCB8fCB7fSxcbiAgICAgICAgc3RvcmVBciA9IGdhLnN0b3JlQXIgfHwgW10sXG4gICAgICAgIG5TdG9yZUFyciA9IFtdLFxuICAgICAgICB5QXhpcyA9IGNhbnZhcy5jb21wb3NpdGlvbi55QXhpcztcbiAgICAgIC8vIENoYW5naW5nIHkgQXhpcyBmb3JtYXR0b3JcbiAgICAgIGlmIChtb2RlID09PSAncmVzZXQnKSB7XG4gICAgICAgIHlBeGlzLmdldFNjYWxlT2JqKCkuZ2V0SW50ZXJ2YWxPYmooKS5nZXRDb25maWcoJ2ludGVydmFscycpLm1ham9yLmZvcm1hdHRlciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeUF4aXMuZ2V0U2NhbGVPYmooKS5nZXRJbnRlcnZhbE9iaigpLmdldENvbmZpZygnaW50ZXJ2YWxzJykubWFqb3IuZm9ybWF0dGVyID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgIHJldHVybiB2YWwgKyAnJSc7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvLyBEZWNsYXJhdGlvbiBlbmRzXG4gICAgICB0aGlzLmdhID0gZ2E7XG4gICAgICBpZiAoIWdhLnN0b3JlQXIpIHtcbiAgICAgICAgc3RvcmUgPSB7fTtcbiAgICAgICAgaWYgKCFnYS5pZE1hcCkge1xuICAgICAgICAgIGRzLmZvckVhY2hTZXJpZXMoZnVuY3Rpb24gKGEsIGIsIGMsIHNlcmllcykge1xuICAgICAgICAgICAgc3RvcmVbc2VyaWVzLmdldElkKCldID0gc2VyaWVzLmdldE9yaWdpbmFsRGF0YSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvciAoaSBpbiBzdG9yZSkge1xuICAgICAgICAgICAgc3RvcmVBci5wdXNoKHN0b3JlW2ldKTtcbiAgICAgICAgICAgIGlkTWFwW2ldID0gc3RvcmVBci5sZW5ndGggLSAxO1xuICAgICAgICAgICAgLy8gPSBzdG9yZVtpXS5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIDIwICogZSArIChNYXRoLnJhbmRvbSgpICogMTAwMCk7IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBnYS5pZE1hcCA9IGlkTWFwO1xuICAgICAgICAgIGdhLmRzID0gZHM7XG4gICAgICAgICAgZ2Euc3RvcmVBciA9IHN0b3JlQXI7XG4gICAgICAgICAgZ2EuZ0FuYWx5c2VyID0gbmV3IEdyb3d0aEFuYWx5c2VyKHN0b3JlQXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuU3RvcmVBcnIgPSBnYS5nQW5hbHlzZXIuYW5hbHlzZShtb2RlKTtcbiAgICAgIGRzLnNldERhdGFCeVNlcmllcyhmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgICAgIGlmIChuU3RvcmVBcnIubGVuZ3RoKSB7XG4gICAgICAgICAgc2VyaWVzLnNldE9yaWdpbmFsRGF0YShuU3RvcmVBcnJbaWRNYXBbc2VyaWVzLmdldElkKCldXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29tcC5pbXBsLnVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICBpbml0IChyZXF1aXJlKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzO1xuICAgICAgcmVxdWlyZShbXG4gICAgICAgICd4QXhpcycsXG4gICAgICAgICd5QXhpcycsXG4gICAgICAgICdncmFwaGljcycsXG4gICAgICAgICdjaGFydCcsXG4gICAgICAgICdkYXRhc2V0JyxcbiAgICAgICAgJ1Bsb3RNYW5hZ2VyJyxcbiAgICAgICAgJ2NhbnZhc0NvbmZpZycsXG4gICAgICAgICdNYXJrZXJNYW5hZ2VyJyxcbiAgICAgICAgJ3JlYWN0aXZlTW9kZWwnLFxuICAgICAgICAnZ2xvYmFsUmVhY3RpdmVNb2RlbCcsXG4gICAgICAgICdzcGFjZU1hbmFnZXJJbnN0YW5jZScsXG4gICAgICAgICdzbWFydExhYmVsJyxcbiAgICAgICAgJ2NoYXJ0SW5zdGFuY2UnLFxuICAgICAgICAnZXh0RGF0YScsXG4gICAgICAgICdjYW52YXNEYXRhJyxcbiAgICAgICAgZnVuY3Rpb24gKFxuICAgICAgICAgICAgICB4QXhpcyxcbiAgICAgICAgICAgICAgeUF4aXMsXG4gICAgICAgICAgICAgIGdyYXBoaWNzLFxuICAgICAgICAgICAgICBjaGFydCxcbiAgICAgICAgICAgICAgZGF0YXNldCxcbiAgICAgICAgICAgICAgcGxvdE1hbmFnZXIsXG4gICAgICAgICAgICAgIGNhbnZhc0NvbmZpZyxcbiAgICAgICAgICAgICAgbWFya2VyTWFuYWdlcixcbiAgICAgICAgICAgICAgcmVhY3RpdmVNb2RlbCxcbiAgICAgICAgICAgICAgZ2xvYmFsUmVhY3RpdmVNb2RlbCxcbiAgICAgICAgICAgICAgc3BhY2VNYW5hZ2VySW5zdGFuY2UsXG4gICAgICAgICAgICAgIHNtYXJ0TGFiZWwsXG4gICAgICAgICAgICAgIGNoYXJ0SW5zdGFuY2UsXG4gICAgICAgICAgICAgIGV4dERhdGEsXG4gICAgICAgICAgICAgIGNhbnZhc0RhdGEpIHtcbiAgICAgICAgICBpbnN0YW5jZS54QXhpcyA9IHhBeGlzO1xuICAgICAgICAgIGluc3RhbmNlLnlBeGlzID0geUF4aXM7XG4gICAgICAgICAgaW5zdGFuY2UuZ3JhcGhpY3MgPSBncmFwaGljcztcbiAgICAgICAgICBpbnN0YW5jZS5jaGFydCA9IGNoYXJ0O1xuICAgICAgICAgIGluc3RhbmNlLmRhdGFzZXQgPSBkYXRhc2V0O1xuICAgICAgICAgIGluc3RhbmNlLnBsb3RNYW5hZ2VyID0gcGxvdE1hbmFnZXI7XG4gICAgICAgICAgaW5zdGFuY2UubWFya2VyTWFuYWdlciA9IG1hcmtlck1hbmFnZXI7XG4gICAgICAgICAgaW5zdGFuY2UuY2FudmFzQ29uZmlnID0gY2FudmFzQ29uZmlnO1xuICAgICAgICAgIGluc3RhbmNlLnJlYWN0aXZlTW9kZWwgPSByZWFjdGl2ZU1vZGVsO1xuICAgICAgICAgIGluc3RhbmNlLmdsb2JhbFJlYWN0aXZlTW9kZWwgPSBnbG9iYWxSZWFjdGl2ZU1vZGVsO1xuICAgICAgICAgIGluc3RhbmNlLnNwYWNlTWFuYWdlckluc3RhbmNlID0gc3BhY2VNYW5hZ2VySW5zdGFuY2U7XG4gICAgICAgICAgaW5zdGFuY2Uuc21hcnRMYWJlbCA9IHNtYXJ0TGFiZWw7XG4gICAgICAgICAgaW5zdGFuY2UuY2hhcnRJbnN0YW5jZSA9IGNoYXJ0SW5zdGFuY2U7XG4gICAgICAgICAgaW5zdGFuY2UuY2FudmFzRGF0YSA9IGNhbnZhc0RhdGE7XG4gICAgICAgICAgaW5zdGFuY2UuZXh0RGF0YSA9IGV4dERhdGE7XG4gICAgICAgIH1cbiAgICAgIF0pO1xuICAgICAgLy8gIGNvbnNvbGUubG9nKGluc3RhbmNlLmV4dERhdGEpO1xuICAgICAgdGhpcy5zcGFjZU1hbmFnZXJJbnN0YW5jZSA9IGluc3RhbmNlLnNwYWNlTWFuYWdlckluc3RhbmNlO1xuICAgICAgdGhpcy5nbG9iYWxSZWFjdGl2ZU1vZGVsID0gaW5zdGFuY2UuZ2xvYmFsUmVhY3RpdmVNb2RlbDtcbiAgICAgIHRoaXMudHNPYmplY3QgPSBpbnN0YW5jZS5jaGFydEluc3RhbmNlO1xuICAgICAgdGhpcy5zdGFydER0ID0gaW5zdGFuY2UuZ2xvYmFsUmVhY3RpdmVNb2RlbC5tb2RlbFsneC1heGlzLXZpc2libGUtcmFuZ2Utc3RhcnQnXTtcbiAgICAgIHRoaXMuZW5kRHQgPSBpbnN0YW5jZS5nbG9iYWxSZWFjdGl2ZU1vZGVsLm1vZGVsWyd4LWF4aXMtdmlzaWJsZS1yYW5nZS1lbmQnXTtcbiAgICAgIHRoaXMuc3RhcnREYXRhc2V0ID0gaW5zdGFuY2UuZ2xvYmFsUmVhY3RpdmVNb2RlbC5tb2RlbFsneC1heGlzLWFic29sdXRlLXJhbmdlLXN0YXJ0J107XG4gICAgICB0aGlzLmVuZERhdGFzZXQgPSBpbnN0YW5jZS5nbG9iYWxSZWFjdGl2ZU1vZGVsLm1vZGVsWyd4LWF4aXMtYWJzb2x1dGUtcmFuZ2UtZW5kJ107XG4gICAgICB0aGlzLnRvb2xiYXJzID0gW107XG4gICAgICB0aGlzLm1lYXN1cmVtZW50ID0ge307XG4gICAgICB0aGlzLnRvb2xiYXJzLnB1c2godGhpcy5jcmVhdGVUb29sYmFyKCkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGNyZWF0ZVRvb2xiYXIgKCkge1xuICAgICAgdmFyIHRvb2xiYXIsXG4gICAgICAgIGdyb3VwLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgY29udGV4dE1lbnUsXG4gICAgICAgIGNvbnRleHRBcnJheSA9IFtdLFxuICAgICAgICBnYU9wdGlvbnNPYmogPSB7fSxcbiAgICAgICAgcG9wdXAsXG4gICAgICAgIHBhcGVyID0gdGhpcy5ncmFwaGljcy5wYXBlcixcbiAgICAgICAgY2hhcnRDb250YWluZXIgPSB0aGlzLmdyYXBoaWNzLmNvbnRhaW5lcixcbiAgICAgICAgc3ViQ2F0U3R5bGUgPSB7XG4gICAgICAgICAgJ2ZvbnQtc2l6ZSc6ICcxMnB4JyxcbiAgICAgICAgICAnY29sb3InOiAnIzRiNGI0YicsXG4gICAgICAgICAgJ2ZvbnQtZmFtaWx5JzogJ1wiTHVjaWRhIEdyYW5kZVwiLCBTYW5zLXNlcmlmJ1xuICAgICAgICB9LFxuICAgICAgICBjYXRTdHlsZSA9IHtcbiAgICAgICAgICAnZm9udC1zaXplJzogJzEzcHgnLFxuICAgICAgICAgICdjb2xvcic6ICcjNGI0YjRiJyxcbiAgICAgICAgICAnZm9udC1mYW1pbHknOiAnXCJMdWNpZGEgR3JhbmRlXCIsIFNhbnMtc2VyaWYnLFxuICAgICAgICAgICdmb250V2VpZ2h0JzogJ2JvbGQnXG4gICAgICAgIH07XG5cbiAgICAgIHRvb2xiYXIgPSBuZXcgdGhpcy5Ib3Jpem9udGFsVG9vbGJhcih7XG4gICAgICAgIHBhcGVyOiB0aGlzLmdyYXBoaWNzLnBhcGVyLFxuICAgICAgICBjaGFydDogdGhpcy5jaGFydCxcbiAgICAgICAgc21hcnRMYWJlbDogdGhpcy5zbWFydExhYmVsLFxuICAgICAgICBjaGFydENvbnRhaW5lcjogdGhpcy5ncmFwaGljcy5jb250YWluZXJcbiAgICAgIH0pO1xuXG4gICAgICB0b29sYmFyLnNldENvbmZpZyh7XG4gICAgICAgIGZpbGw6ICcjZmZmJyxcbiAgICAgICAgYm9yZGVyVGhpY2tuZXNzOiAwXG4gICAgICB9KTtcblxuICAgICAgZ3JvdXAgPSBuZXcgdGhpcy50b29sYm94LkNvbXBvbmVudEdyb3VwKHtcbiAgICAgICAgcGFwZXI6IHRoaXMuZ3JhcGhpY3MucGFwZXIsXG4gICAgICAgIGNoYXJ0OiB0aGlzLmNoYXJ0LFxuICAgICAgICBzbWFydExhYmVsOiB0aGlzLnNtYXJ0TGFiZWwsXG4gICAgICAgIGNoYXJ0Q29udGFpbmVyOiB0aGlzLmdyYXBoaWNzLmNvbnRhaW5lclxuICAgICAgfSk7XG5cbiAgICAgIGdyb3VwLnNldENvbmZpZyh7XG4gICAgICAgIGZpbGw6ICcjZmZmJyxcbiAgICAgICAgYm9yZGVyVGhpY2tuZXNzOiAwXG4gICAgICB9KTtcblxuICAgICAgZ2FPcHRpb25zT2JqID0ge1xuICAgICAgICAnRmlyc3QgSW5kZXgnOiB7cG9zaXRpb246IDB9LFxuICAgICAgICAnUHJldmlvdXMgSW5kZXgnOiB7cmVscG9zaXRpb246IC0xfSxcbiAgICAgICAgJ1NwZWNpZmljIFZhbHVlJzoge1xuICAgICAgICAgICdzdWJtZW51JzogdHJ1ZSxcbiAgICAgICAgICAnTWluaW11bSc6ICdNaW5pbXVtJyxcbiAgICAgICAgICAnTWF4aW11bSc6ICdNYXhpbXVtJyxcbiAgICAgICAgICAnTWVhbic6ICdNZWFuJyxcbiAgICAgICAgICAnTWVkaWFuJzogJ01lZGlhbicsXG4gICAgICAgICAgJ1N0YW5kYXJkIERldmlhdGlvbic6ICdTdGFuZGFyZCBEZXZpYXRpb24nLFxuICAgICAgICAgICdDdXN0b20gVmFsdWUuLi4nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwb3B1cCgodmFsKSA9PiBzZWxmLmFuYWx5c2VyKHZhbCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29udGV4dE1lbnUgPSBuZXcgdGhpcy50b29sYm94LlN5bWJvbFdpdGhDb250ZXh0KCdDb250ZXh0SWNvbicsIHtcbiAgICAgICAgcGFwZXI6IHRoaXMuZ3JhcGhpY3MucGFwZXIsXG4gICAgICAgIGNoYXJ0OiB0aGlzLmNoYXJ0LFxuICAgICAgICBzbWFydExhYmVsOiB0aGlzLnNtYXJ0TGFiZWwsXG4gICAgICAgIGNoYXJ0Q29udGFpbmVyOiB0aGlzLmdyYXBoaWNzLmNvbnRhaW5lclxuICAgICAgfSwge1xuICAgICAgICB3aWR0aDogMjQsXG4gICAgICAgIGhlaWdodDogMjQsXG4gICAgICAgIHBvc2l0aW9uOiAncmlnaHQnLFxuICAgICAgICBzdHJva2U6ICcjY2VkNWQ0JyxcbiAgICAgICAgc3Ryb2tlV2lkdGg6ICcxJyxcbiAgICAgICAgcmFkaXVzOiAnMScsXG4gICAgICAgIHN5bWJvbFN0cm9rZTogJyM2OTY5NjknLFxuICAgICAgICBzeW1ib2xTdHJva2VXaWR0aDogJzInXG4gICAgICB9KTtcblxuICAgICAgY29udGV4dEFycmF5LnB1c2goe1xuICAgICAgICAnR3Jvd3RoIEFuYWx5c2VyJzoge1xuICAgICAgICAgIHN0eWxlOiBjYXRTdHlsZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHBvcHVwID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBib3gsXG4gICAgICAgICAgaGVhZGVyLFxuICAgICAgICAgIHN0eWxlID0ge1xuICAgICAgICAgICAgZm9udFNpemU6IDEwICsgJ3B4JyxcbiAgICAgICAgICAgIGxpbmVIZWlnaHQ6IDE1ICsgJ3B4JyxcbiAgICAgICAgICAgICdmb250LWZhbWlseSc6ICdcIkx1Y2lkYSBHcmFuZGVcIiwgU2Fucy1zZXJpZicsXG4gICAgICAgICAgICBzdHJva2U6ICcjNjc2NzY3JyxcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAnMidcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhlYWRlcldpZHRoID0gMTgwLFxuICAgICAgICAgIGhlYWRlclRleHQsXG4gICAgICAgICAgY3Jvc3MsXG4gICAgICAgICAgaW5wdXRGaWVsZCxcbiAgICAgICAgICBhcHBseUJ1dHRvbixcbiAgICAgICAgICB4ID0gKHNlbGYuY2hhcnQud2lkdGggKiAwLjQ3KSAtIDkwLFxuICAgICAgICAgIHkgPSBzZWxmLmNoYXJ0LmhlaWdodCAvIDIgLSA0MDtcblxuICAgICAgICBib3ggPSBwYXBlci5odG1sKCdkaXYnLCB7XG4gICAgICAgICAgZmlsbDogJyNmN2Y3ZjcnLFxuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICB3aWR0aDogMTgwLFxuICAgICAgICAgIGhlaWdodDogODBcbiAgICAgICAgfSwgc3R5bGUsIGNoYXJ0Q29udGFpbmVyKTtcblxuICAgICAgICBoZWFkZXIgPSBwYXBlci5odG1sKCdkaXYnLCB7XG4gICAgICAgICAgZmlsbDogJyNlOGU4ZTgnLFxuICAgICAgICAgIHdpZHRoOiBoZWFkZXJXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IDIwXG4gICAgICAgIH0sIHN0eWxlLCBib3gpO1xuXG4gICAgICAgIGhlYWRlclRleHQgPSBwYXBlci5odG1sKCdkaXYnLCB7XG4gICAgICAgICAgZmlsbDogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICB3aWR0aDogaGVhZGVyV2lkdGggKiAwLjYsXG4gICAgICAgICAgaGVpZ2h0OiAyMCxcbiAgICAgICAgICB4OiAxMCxcbiAgICAgICAgICB5OiAyXG4gICAgICAgIH0sIHN0eWxlLCBoZWFkZXIpO1xuXG4gICAgICAgIGhlYWRlclRleHQuYXR0cih7XG4gICAgICAgICAgdGV4dDogJ1Byb3ZpZGUgdmFsdWUnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNyb3NzID0gcGFwZXIuaHRtbCgnZGl2Jywge1xuICAgICAgICAgIGZpbGw6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgd2lkdGg6IDEwLFxuICAgICAgICAgIGhlaWdodDogMTAsXG4gICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgZmxvYXQ6ICdyaWdodCcsXG4gICAgICAgICAgdGV4dDogJ1gnLFxuICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICAgIH0sIHN0eWxlLCBoZWFkZXIpO1xuXG4gICAgICAgIGNyb3NzLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBib3guaGlkZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpbnB1dEZpZWxkID0gcGFwZXIuaHRtbCgnaW5wdXQnLCB7XG4gICAgICAgICAgd2lkdGg6IDEwMCxcbiAgICAgICAgICBoZWlnaHQ6IDIwLFxuICAgICAgICAgIHg6IDEwLFxuICAgICAgICAgIHk6IDMwXG4gICAgICAgIH0sIHN0eWxlLCBib3gpO1xuXG4gICAgICAgIGFwcGx5QnV0dG9uID0gcGFwZXIuaHRtbCgnZGl2Jywge1xuICAgICAgICAgIHdpZHRoOiA1MCxcbiAgICAgICAgICBoZWlnaHQ6IDIwLFxuICAgICAgICAgIHg6IDEyMCxcbiAgICAgICAgICB5OiAzMCxcbiAgICAgICAgICBmaWxsOiAnIzU1NTU1NSdcbiAgICAgICAgfSwge1xuICAgICAgICAgIGZvbnRTaXplOiAxMCArICdweCcsXG4gICAgICAgICAgbGluZUhlaWdodDogMTUgKyAncHgnLFxuICAgICAgICAgICdmb250LWZhbWlseSc6ICdcIkx1Y2lkYSBHcmFuZGVcIiwgU2Fucy1zZXJpZicsXG4gICAgICAgICAgZmlsbDogJyNlYWVhZWEnLFxuICAgICAgICAgIGNvbG9yOiAnI2VhZWFlYScsXG4gICAgICAgICAgc3Ryb2tlOiAnI2VhZWFlYScsXG4gICAgICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICAgICAgfSwgYm94KTtcblxuICAgICAgICBmdW5jdGlvbiBhcHBseVZhbHVlICgpIHtcbiAgICAgICAgICBib3guaGlkZSgpO1xuICAgICAgICAgIGNhbGxiYWNrKGlucHV0RmllbGQudmFsKCkpO1xuICAgICAgICB9XG4gICAgICAgIGFwcGx5QnV0dG9uLm9uKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICBhcHBseVZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpbnB1dEZpZWxkLm9uKCdrZXl1cCcsIChlKSA9PiB7XG4gICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgIGFwcGx5VmFsdWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhcHBseUJ1dHRvbi5hdHRyKHtcbiAgICAgICAgICB0ZXh0OiAnQXBwbHknXG4gICAgICAgIH0pO1xuICAgICAgICBpbnB1dEZpZWxkLmVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgZnVuY3Rpb24gaW5wdXRGaWVsZE51bWJlckhhbmRsZXIgKCkge1xuICAgICAgICAgIGlucHV0RmllbGQuZWxlbWVudC52YWx1ZSA9IGlucHV0RmllbGQuZWxlbWVudC52YWx1ZS5yZXBsYWNlKC9bXlxcZC4tXS9nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXRGaWVsZC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgaW5wdXRGaWVsZE51bWJlckhhbmRsZXIpO1xuICAgICAgICBjcm9zcy5lbGVtZW50LnN0eWxlWydwb3NpdGlvbiddID0gJ3JlbGF0aXZlJztcbiAgICAgICAgY3Jvc3MuZWxlbWVudC5zdHlsZVsnYmFja2dyb3VuZENvbG9yJ10gPSAnI2QyZDJkMic7XG4gICAgICAgIGNyb3NzLmVsZW1lbnQuc3R5bGVbJ2JvcmRlciddID0gJzJweCBzb2xpZCAjY2JjYmNiJztcbiAgICAgICAgY3Jvc3MuZWxlbWVudC5zdHlsZVsncGFkZGluZyddID0gJzBweCAwcHggMy41cHggMnB4JztcbiAgICAgICAgY3Jvc3MuZWxlbWVudC5zdHlsZVsnY29sb3InXSA9ICcjOGM4YzhjJztcbiAgICAgICAgY3Jvc3MuZWxlbWVudC5zdHlsZVsnbWFyZ2luJ10gPSAnMXB4IDJweCc7XG4gICAgICAgIGNyb3NzLmVsZW1lbnQuc3R5bGVbJ2Zsb2F0J10gPSAncmlnaHQnO1xuICAgICAgICBpbnB1dEZpZWxkLmVsZW1lbnQuc3R5bGVbJ21hcmdpblRvcCddID0gJzhweCc7XG4gICAgICAgIGlucHV0RmllbGQuZWxlbWVudC5zdHlsZVsnYm9yZGVyJ10gPSAnMnB4IHNvbGlkICNkYWRiZGEnO1xuICAgICAgICBhcHBseUJ1dHRvbi5lbGVtZW50LnN0eWxlWydtYXJnaW5Ub3AnXSA9ICc4cHgnO1xuICAgICAgICBib3guZWxlbWVudC5zdHlsZVsnYm9yZGVyJ10gPSAnMXB4IHNvbGlkICNkNGQyZDMnO1xuICAgICAgICBoZWFkZXIuZWxlbWVudC5zdHlsZVsnYm9yZGVyJ10gPSAnMXB4IHNvbGlkICNkNGQyZDMnO1xuICAgICAgICBoZWFkZXIuZWxlbWVudC5zdHlsZVsnd2lkdGgnXSA9ICcxNzlweCc7XG4gICAgICAgIGhlYWRlclRleHQuZWxlbWVudC5zdHlsZVsnZm9udFNpemUnXSA9ICcxMS41cHgnO1xuICAgICAgICBoZWFkZXJUZXh0LmVsZW1lbnQuc3R5bGVbJ21hcmdpblRvcCddID0gJzAuNXB4JztcbiAgICAgICAgaGVhZGVyVGV4dC5lbGVtZW50LnN0eWxlWydjb2xvciddID0gJyM2NzY3NjcnO1xuICAgICAgICBoZWFkZXIuZWxlbWVudC5zdHlsZVsnZm9udC1mYW1pbHknXSA9ICdcIkx1Y2lkYSBHcmFuZGVcIiwgU2Fucy1zZXJpZic7XG4gICAgICAgIGFwcGx5QnV0dG9uLmVsZW1lbnQuc3R5bGVbJ3RleHRBbGlnbiddID0gJ2NlbnRlcic7XG4gICAgICAgIGFwcGx5QnV0dG9uLmVsZW1lbnQuc3R5bGVbJ2ZvbnRTaXplJ10gPSAnMTFweCc7XG4gICAgICAgIGFwcGx5QnV0dG9uLmVsZW1lbnQuc3R5bGVbJ3BhZGRpbmdUb3AnXSA9ICczcHgnO1xuICAgICAgICBhcHBseUJ1dHRvbi5lbGVtZW50LnN0eWxlWydib3JkZXJSYWRpdXMnXSA9ICczcHgnO1xuICAgICAgICBhcHBseUJ1dHRvbi5lbGVtZW50LnN0eWxlWydjb2xvciddID0gJyNlNGU0ZTQnO1xuICAgICAgfTtcblxuICAgICAgZm9yIChsZXQgaSBpbiBnYU9wdGlvbnNPYmopIHtcbiAgICAgICAgbGV0IGtleSxcbiAgICAgICAgICBvYmogPSB7fSxcbiAgICAgICAgICBzdWJPYmogPSB7fTtcbiAgICAgICAgaWYgKCFnYU9wdGlvbnNPYmpbaV0uc3VibWVudSkge1xuICAgICAgICAgIGtleSA9ICcmbmJzcDsgJm5ic3A7ICcgKyBpO1xuICAgICAgICAgIG9ialtrZXldID0ge307XG4gICAgICAgICAgb2JqW2tleV0gPSB7XG4gICAgICAgICAgICBzdHlsZTogc3ViQ2F0U3R5bGUsXG4gICAgICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHNlbGYuYW5hbHlzZXIoZ2FPcHRpb25zT2JqW2ldKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhY3Rpb246ICdjbGljaydcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleSA9ICcmIzk2NjYmbmJzcDsgJyArIGk7XG4gICAgICAgICAgb2JqW2tleV0gPSB7fTtcbiAgICAgICAgICBvYmpba2V5XS5hY3Rpb24gPSAnY2xpY2snO1xuICAgICAgICAgIG9ialtrZXldLnN0eWxlID0gc3ViQ2F0U3R5bGU7XG4gICAgICAgICAgb2JqW2tleV0uaGFuZGxlciA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGogaW4gZ2FPcHRpb25zT2JqW2ldKSB7XG4gICAgICAgICAgICBsZXQgc3ViTWVudU5hbWUgPSBqLFxuICAgICAgICAgICAgICBzdWJNZW51VmFsdWUgPSBnYU9wdGlvbnNPYmpbaV1bal07XG4gICAgICAgICAgICBpZiAoaiA9PT0gJ3N1Ym1lbnUnKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3ViT2JqID0ge307XG4gICAgICAgICAgICBzdWJPYmpbJyZuYnNwOycgKyBzdWJNZW51TmFtZV0gPSB7fTtcbiAgICAgICAgICAgIHN1Yk9ialsnJm5ic3A7JyArIHN1Yk1lbnVOYW1lXS5oYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHN1Yk1lbnVWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHN1Yk1lbnVWYWx1ZSgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuYW5hbHlzZXIoc3ViTWVudVZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHN1Yk9ialsnJm5ic3A7JyArIHN1Yk1lbnVOYW1lXS5hY3Rpb24gPSAnY2xpY2snO1xuICAgICAgICAgICAgc3ViT2JqWycmbmJzcDsnICsgc3ViTWVudU5hbWVdLnN0eWxlID0gc3ViQ2F0U3R5bGU7XG4gICAgICAgICAgICBvYmpba2V5XS5oYW5kbGVyLnB1c2goc3ViT2JqKTtcbiAgICAgICAgICAgIGlmIChqLmluZGV4T2YoJ0N1c3RvbScpID09PSAtMSkge1xuICAgICAgICAgICAgICBvYmpba2V5XS5oYW5kbGVyLnB1c2goe1xuICAgICAgICAgICAgICAgICcnOiB7XG4gICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZDVkMmQyJyxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMXB4JyxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAnMXB4JyxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogJzBweCdcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0QXJyYXkucHVzaChvYmopO1xuICAgICAgICBjb250ZXh0QXJyYXkucHVzaCh7XG4gICAgICAgICAgJyc6IHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNkNWQyZDInLFxuICAgICAgICAgICAgICBoZWlnaHQ6ICcxcHgnLFxuICAgICAgICAgICAgICBtYXJnaW46ICcxcHgnLFxuICAgICAgICAgICAgICBwYWRkaW5nOiAnMHB4J1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHRBcnJheS5wdXNoKHtcbiAgICAgICAgJyZuYnNwOyAmbmJzcDsgUmVzZXQgVmlldyc6IHtcbiAgICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLmFuYWx5c2VyKCdyZXNldCcpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWN0aW9uOiAnY2xpY2snLFxuICAgICAgICAgIHN0eWxlOiBzdWJDYXRTdHlsZVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29udGV4dE1lbnUuYXBwZW5kQXNMaXN0KGNvbnRleHRBcnJheSk7XG5cbiAgICAgIHRoaXMuU3ltYm9sU3RvcmUucmVnaXN0ZXIoJ0NvbnRleHRJY29uJywgZnVuY3Rpb24gKHBvc3gsIHBvc3ksIHJhZCkge1xuICAgICAgICB2YXIgeCA9IHBvc3gsXG4gICAgICAgICAgeSA9IHBvc3ksXG4gICAgICAgICAgciA9IHJhZCAqIDIsXG4gICAgICAgICAgc3BhY2UgPSBNYXRoLnJvdW5kKHIgLyA0KSxcbiAgICAgICAgICBoYWxmV2lkdGggPSBNYXRoLnJvdW5kKHIgLyAyKSAqIDAuNyxcbiAgICAgICAgICBzdGFydFggPSAoeCAtIGhhbGZXaWR0aCksXG4gICAgICAgICAgZW5kWCA9ICh4ICsgaGFsZldpZHRoKSxcbiAgICAgICAgICBzdGFydFkgPSAoeSArIHNwYWNlKSxcbiAgICAgICAgICBlbmRZID0gKHkgLSBzcGFjZSk7XG4gICAgICAgIHJldHVybiBbJ00nLCBzdGFydFgsIHksICdMJywgZW5kWCwgeSwgJ00nLCBzdGFydFgsIHN0YXJ0WSwgJ0wnLCBlbmRYLCBzdGFydFksICdNJywgc3RhcnRYLCBlbmRZLCAnTCcsIGVuZFgsIGVuZFldO1xuICAgICAgfSk7XG5cbiAgICAgIGdyb3VwLmFkZFN5bWJvbChjb250ZXh0TWVudSk7XG4gICAgICB0b29sYmFyLmFkZENvbXBvbmVudChncm91cCk7XG4gICAgICByZXR1cm4gdG9vbGJhcjtcbiAgICB9O1xuXG4gICAgZ2V0TG9naWNhbFNwYWNlIChhdmFpbGFibGVXaWR0aCwgYXZhaWxhYmxlSGVpZ2h0KSB7XG4gICAgICBhdmFpbGFibGVXaWR0aCAvPSAyO1xuICAgICAgdmFyIGxvZ2ljYWxTcGFjZSxcbiAgICAgICAgd2lkdGggPSAwLFxuICAgICAgICBoZWlnaHQgPSAwLFxuICAgICAgICBpLFxuICAgICAgICBsbjtcblxuICAgICAgZm9yIChpID0gMCwgbG4gPSB0aGlzLnRvb2xiYXJzLmxlbmd0aDsgaSA8IGxuOyBpKyspIHtcbiAgICAgICAgbG9naWNhbFNwYWNlID0gdGhpcy50b29sYmFyc1tpXS5nZXRMb2dpY2FsU3BhY2UoYXZhaWxhYmxlV2lkdGgsIGF2YWlsYWJsZUhlaWdodCk7XG4gICAgICAgIHdpZHRoID0gTWF0aC5tYXgobG9naWNhbFNwYWNlLndpZHRoLCB3aWR0aCk7XG4gICAgICAgIGhlaWdodCArPSBsb2dpY2FsU3BhY2UuaGVpZ2h0O1xuICAgICAgICB0aGlzLnRvb2xiYXJzW2ldLndpZHRoID0gbG9naWNhbFNwYWNlLndpZHRoO1xuICAgICAgICB0aGlzLnRvb2xiYXJzW2ldLmhlaWdodCA9IGxvZ2ljYWxTcGFjZS5oZWlnaHQ7XG4gICAgICB9XG4gICAgICBoZWlnaHQgKz0gdGhpcy5wYWRkaW5nO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHdpZHRoID4gYXZhaWxhYmxlV2lkdGggPyAwIDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ID4gYXZhaWxhYmxlSGVpZ2h0ID8gMCA6IGhlaWdodFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgcGxhY2VJbkNhbnZhcyAoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBzZWxmLnBhZGRpbmcgPSA1O1xuICAgICAgc2VsZi5zcGFjZU1hbmFnZXJJbnN0YW5jZS5hZGQoW3tcbiAgICAgICAgbmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAnVG9vbEJveEV4dCc7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZjogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIHJldHVybiBvYmpbJzAnXTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VsZjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9LFxuICAgICAgICBwcmlvcml0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9LFxuICAgICAgICBsYXlvdXQ6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICByZXR1cm4gb2JqLmlubGluZTtcbiAgICAgICAgfSxcbiAgICAgICAgb3JpZW50YXRpb246IFt7XG4gICAgICAgICAgdHlwZTogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5ob3Jpem9udGFsO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcG9zaXRpb246IFt7XG4gICAgICAgICAgICB0eXBlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvYmoudG9wO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFsaWdubWVudDogW3tcbiAgICAgICAgICAgICAgdHlwZTogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmoucmlnaHQ7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGRpbWVuc2lvbnM6IFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50Q29tcG9uZW50R3JvdXAoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRMb2dpY2FsU3BhY2UocGFyZW50LmdldFdpZHRoKCksIHBhcmVudC5nZXRIZWlnaHQoKSk7XG4gICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH1dXG4gICAgICAgIH1dXG4gICAgICB9XSk7XG4gICAgfTtcblxuICAgIHNldERyYXdpbmdDb25maWd1cmF0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBncm91cCkge1xuICAgICAgdmFyIG1lcyA9IHRoaXMubWVhc3VyZW1lbnQ7XG4gICAgICBtZXMueCA9IHg7XG4gICAgICBtZXMueSA9IHk7XG4gICAgICBtZXMud2lkdGggPSB3aWR0aDtcbiAgICAgIG1lcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgIHRoaXMucGFyZW50R3JvdXAgPSBncm91cDtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGRyYXcgKHgsIHksIHdpZHRoLCBoZWlnaHQsIGdyb3VwKSB7XG4gICAgICB2YXIgbWVhc3VyZW1lbnQgPSB0aGlzLm1lYXN1cmVtZW50LFxuICAgICAgICB0b29sYmFycyA9IHRoaXMudG9vbGJhcnMsXG4gICAgICAgIGxuLFxuICAgICAgICBpLFxuICAgICAgICB0b29sYmFyO1xuICAgICAgeCA9IHggPT09IHVuZGVmaW5lZCA/IG1lYXN1cmVtZW50LnggOiB4O1xuICAgICAgeSA9IHkgPT09IHVuZGVmaW5lZCA/IG1lYXN1cmVtZW50LnkgOiB5O1xuICAgICAgd2lkdGggPSB3aWR0aCA9PT0gdW5kZWZpbmVkID8gbWVhc3VyZW1lbnQud2lkdGggOiB3aWR0aDtcbiAgICAgIGhlaWdodCA9IGhlaWdodCA9PT0gdW5kZWZpbmVkID8gbWVhc3VyZW1lbnQuaGVpZ2h0IDogaGVpZ2h0O1xuICAgICAgZ3JvdXAgPSBncm91cCA9PT0gdW5kZWZpbmVkID8gdGhpcy5wYXJlbnRHcm91cCA6IGdyb3VwO1xuICAgICAgaWYgKHdpZHRoICYmIGhlaWdodCkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsbiA9IHRvb2xiYXJzLmxlbmd0aDsgaSA8IGxuOyBpKyspIHtcbiAgICAgICAgICB0b29sYmFyID0gdG9vbGJhcnNbaV07XG4gICAgICAgICAgdG9vbGJhci5kcmF3KHgsIHkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgRnVzaW9uQ2hhcnRzLnJlZ2lzdGVyQ29tcG9uZW50KCdleHRlbnNpb25zJywgJ2dyb3d0aC1hbmFseXNlci1leHQnLCBHcm93dGhBbmFseXNlckV4dCk7XG59XSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9leHRlbnNpb24uanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuY2xhc3MgR3Jvd3RoQW5hbHlzZXIge1xuICBjb25zdHJ1Y3RvciAoZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGEubWFwKChhKSA9PiB7XG4gICAgICByZXR1cm4gYS5tYXAoKGIpID0+IHsgcmV0dXJuIGI7IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuRm9ybXVsYWUgPSBGb3JtdWxhZTtcbiAgfVxuICBhbmFseXNlIChtb2RlKSB7XG4gICAgbGV0IGkgPSAwLFxuICAgICAgaWkgPSAwLFxuICAgICAgaiA9IDAsXG4gICAgICBqaiA9IDAsXG4gICAgICBudW0gPSAwLFxuICAgICAgY2hlY2tBcnIgPSBbXSxcbiAgICAgIGNoZWNrTnVtID0gMCxcbiAgICAgIGRhdGFBciA9IHRoaXMuZGF0YSxcbiAgICAgIG5EYXRhQXIgPSBbXSxcbiAgICAgIHRlbXBBciA9IFtdLFxuICAgICAgdGVtcCA9IDA7XG4gICAgaWYgKHR5cGVvZiBtb2RlID09PSAnc3RyaW5nJyAmJiBtb2RlLnRvTG93ZXJDYXNlKCkgPT09ICdyZXNldCcpIHtcbiAgICAgIHJldHVybiBkYXRhQXIubWFwKChhKSA9PiB7XG4gICAgICAgIHJldHVybiBhLm1hcCgoYikgPT4geyByZXR1cm4gYjsgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFpc05hTihtb2RlKSkgeyAvLyBIYW5kbGluZyBhIG51bWJlclxuICAgICAgY2hlY2tOdW0gPSArbW9kZTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gZGF0YUFyLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdGVtcEFyID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGpqID0gZGF0YUFyW2ldLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBudW0gPSBkYXRhQXJbaV1bal07XG4gICAgICAgICAgdGVtcEFyLnB1c2goMTAwICogKG51bSAtIGNoZWNrTnVtKSAvIGNoZWNrTnVtKTtcbiAgICAgICAgfVxuICAgICAgICBuRGF0YUFyLnB1c2godGVtcEFyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2RlID09PSAnc3RyaW5nJykge1xuICAgICAgbW9kZSA9IHRoaXMuRm9ybXVsYWVbbW9kZV07XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGRhdGFBci5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHRlbXBBciA9IFtdO1xuICAgICAgICBjaGVja051bSA9IG1vZGUoZGF0YUFyW2ldKTtcbiAgICAgICAgZm9yIChqID0gMCwgamogPSBkYXRhQXJbaV0ubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICAgIG51bSA9IGRhdGFBcltpXVtqXTtcbiAgICAgICAgICBpZiAoY2hlY2tOdW0gPT09IDApIHtcbiAgICAgICAgICAgIHRlbXAgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbXAgPSAxMDAgKiAobnVtIC0gY2hlY2tOdW0pIC8gY2hlY2tOdW07XG4gICAgICAgICAgfVxuICAgICAgICAgIHRlbXBBci5wdXNoKHRlbXApO1xuICAgICAgICB9XG4gICAgICAgIG5EYXRhQXIucHVzaCh0ZW1wQXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzTmFOKG1vZGUucmVscG9zaXRpb24pKSB7XG4gICAgICBtb2RlID0gbW9kZS5yZWxwb3NpdGlvbjtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gZGF0YUFyLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdGVtcEFyID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGpqID0gZGF0YUFyW2ldLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBudW0gPSBkYXRhQXJbaV1bal07XG4gICAgICAgICAgaWYgKGogKyBtb2RlID49IDAgJiYgaiArIG1vZGUgPCBqaikge1xuICAgICAgICAgICAgY2hlY2tOdW0gPSBkYXRhQXJbaV1baiArIG1vZGVdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVja051bSA9IG51bTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGVtcEFyLnB1c2goMTAwICogKG51bSAtIGNoZWNrTnVtKSAvIGNoZWNrTnVtKTtcbiAgICAgICAgfVxuICAgICAgICBuRGF0YUFyLnB1c2godGVtcEFyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc05hTihtb2RlLnBvc2l0aW9uKSB8fCB0eXBlb2YgbW9kZS5wb3NpdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG1vZGUgPSBtb2RlLnBvc2l0aW9uO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBkYXRhQXIubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB0ZW1wQXIgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgamogPSBkYXRhQXJbaV0ubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICAgIG51bSA9IGRhdGFBcltpXVtqXTtcbiAgICAgICAgICBpZiAobW9kZSA9PT0gJ2xhc3QnKSB7XG4gICAgICAgICAgICBjaGVja051bSA9IGRhdGFBcltpXVtqaiAtIDFdO1xuICAgICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ21pZCcpIHtcbiAgICAgICAgICAgIGNoZWNrTnVtID0gZGF0YUFyW2ldW2pqIC8gMl07XG4gICAgICAgICAgfSBlbHNlIGlmIChtb2RlID49IDAgJiYgbW9kZSA8IGpqKSB7XG4gICAgICAgICAgICBjaGVja051bSA9IGRhdGFBcltpXVttb2RlXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tOdW0gPSBudW07XG4gICAgICAgICAgfVxuICAgICAgICAgIHRlbXBBci5wdXNoKDEwMCAqIChudW0gLSBjaGVja051bSkgLyBjaGVja051bSk7XG4gICAgICAgIH1cbiAgICAgICAgbkRhdGFBci5wdXNoKHRlbXBBcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNOYU4obW9kZS5yZWxkYXRhc2V0cG9zaXRpb24pKSB7XG4gICAgICBtb2RlID0gbW9kZS5yZWxkYXRhc2V0cG9zaXRpb247XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGRhdGFBci5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHRlbXBBciA9IFtdO1xuICAgICAgICBpZiAoaSArIG1vZGUgPj0gMCAmJiBpICsgbW9kZSA8IGlpKSB7XG4gICAgICAgICAgY2hlY2tBcnIgPSBkYXRhQXJbaSArIG1vZGVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoZWNrQXJyID0gZGF0YUFyW2ldO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IDAsIGpqID0gZGF0YUFyW2ldLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBjaGVja051bSA9IGNoZWNrQXJyW2pdO1xuICAgICAgICAgIG51bSA9IGRhdGFBcltpXVtqXTtcbiAgICAgICAgICB0ZW1wQXIucHVzaCgxMDAgKiAobnVtIC0gY2hlY2tOdW0pIC8gbnVtKTtcbiAgICAgICAgfVxuICAgICAgICBuRGF0YUFyLnB1c2godGVtcEFyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gMCwgaWkgPSBuRGF0YUFyLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGZvciAoaiA9IDAsIGpqID0gbkRhdGFBcltpXS5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG5EYXRhQXJbaV1bal0pKSB7XG4gICAgICAgICAgbkRhdGFBcltpXVtqXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJvdW5kVG9Ud28gPSAobnVtKSA9PiB7XG4gICAgICByZXR1cm4gKyhNYXRoLnJvdW5kKG51bSArICdlKzInKSArICdlLTInKTtcbiAgICB9O1xuICAgIC8vIFJvdW5kaW5nIHZhbHVlc1xuICAgIGZvciAoaSA9IDAsIGlpID0gbkRhdGFBci5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBmb3IgKGogPSAwLCBqaiA9IG5EYXRhQXJbaV0ubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICBuRGF0YUFyW2ldW2pdID0gcm91bmRUb1R3byhuRGF0YUFyW2ldW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gbkRhdGFBci5sZW5ndGg7IGktLTspIHtcbiAgICAgIGZvciAoaiA9IG5EYXRhQXJbaV0ubGVuZ3RoOyBqLS07KSB7XG4gICAgICAgIHRlbXAgPSBwYXJzZUludChuRGF0YUFyW2ldW2pdICogMTAwKTtcbiAgICAgICAgbkRhdGFBcltpXVtqXSA9IHRlbXAgLyAxMDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuRGF0YUFyO1xuICB9XG59XG5cbnZhciBGb3JtdWxhZSA9IHtcbiAgTWluaW11bTogKGFycikgPT4ge1xuICAgIHJldHVybiBhcnIucmVkdWNlKChhLCBiKSA9PiB7XG4gICAgICByZXR1cm4gYSA+IGIgPyBiIDogYTtcbiAgICB9KTtcbiAgfSxcbiAgTWF4aW11bTogKGFycikgPT4ge1xuICAgIHJldHVybiBhcnIucmVkdWNlKChhLCBiKSA9PiB7XG4gICAgICByZXR1cm4gYSA8IGIgPyBiIDogYTtcbiAgICB9KTtcbiAgfSxcbiAgTWVhbjogKGFycikgPT4ge1xuICAgIHJldHVybiBhcnIucmVkdWNlKChhLCBiKSA9PiB7XG4gICAgICByZXR1cm4gYSArIGI7XG4gICAgfSkgLyBhcnIubGVuZ3RoO1xuICB9LFxuICBNZWRpYW46IChhcnIpID0+IHtcbiAgICByZXR1cm4gYXJyLm1hcCgoYSkgPT4gYSkuc29ydCgoYSwgYikgPT4geyByZXR1cm4gYSAtIGI7IH0pW2Fyci5sZW5ndGggLyAyXTtcbiAgfSxcbiAgJ1N0YW5kYXJkIERldmlhdGlvbic6ICh2YWx1ZXMpID0+IHtcbiAgICBmdW5jdGlvbiBhdmVyYWdlIChkYXRhKSB7XG4gICAgICB2YXIgc3VtLCBhdmc7XG4gICAgICBzdW0gPSBkYXRhLnJlZHVjZShmdW5jdGlvbiAoc3VtLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gc3VtICsgdmFsdWU7XG4gICAgICB9LCAwKTtcblxuICAgICAgYXZnID0gc3VtIC8gZGF0YS5sZW5ndGg7XG4gICAgICByZXR1cm4gYXZnO1xuICAgIH1cbiAgICB2YXIgYXZnID0gMCxcbiAgICAgIHNxdWFyZURpZmZzID0gMCxcbiAgICAgIHNxckRpZmYgPSAwLFxuICAgICAgYXZnU3F1YXJlRGlmZiA9IDAsXG4gICAgICBzdGREZXYgPSAwLFxuICAgICAgZGlmZiA9IDA7XG4gICAgYXZnID0gYXZlcmFnZSh2YWx1ZXMpO1xuICAgIHNxdWFyZURpZmZzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGRpZmYgPSB2YWx1ZSAtIGF2ZztcbiAgICAgIHNxckRpZmYgPSBkaWZmICogZGlmZjtcbiAgICAgIHJldHVybiBzcXJEaWZmO1xuICAgIH0pO1xuICAgIGF2Z1NxdWFyZURpZmYgPSBhdmVyYWdlKHNxdWFyZURpZmZzKTtcbiAgICBzdGREZXYgPSBNYXRoLnNxcnQoYXZnU3F1YXJlRGlmZik7XG4gICAgcmV0dXJuIHN0ZERldjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcm93dGhBbmFseXNlcjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZ3Jvd3RoYW5hbHlzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl19
