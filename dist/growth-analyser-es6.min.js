/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	const GrowthAnalyser = __webpack_require__(2);
	
	FusionCharts.register('extension', ['private', 'legend-ext', function () {
	  function LegendExt () {
	    this.toolbox = FusionCharts.getComponent('api', 'toolbox');
	    this.HorizontalToolbar = this.toolbox.HorizontalToolbar;
	    this.ComponentGroup = this.toolbox.ComponentGroup;
	    this.SymbolStore = this.toolbox.SymbolStore;
	  }
	  LegendExt.prototype.constructor = LegendExt;
	
	  LegendExt.prototype.renderChange = function () {
	    var chartInstance = this.tsObject.chartInstance,
	      componentStore = chartInstance.apiInstance.getComponentStore(),
	      i = 0;
	    for (i = 0; componentStore.getCanvasByIndex(i); ++i) {
	      componentStore.getCanvasByIndex(i).getComposition().PlotManager.plot();
	    }
	  };
	
	  LegendExt.prototype.analyser = function (mode) {
	    var ga = this.ga || {},
	      store = this.tsObject.apiInstance.getComponentStore(),
	      canvas = store.getCanvasByIndex(0),
	      nav = store.getNavigatorByIndex(0),
	      comp = canvas.getComposition(),
	      ds = ga.ds || comp.dataset,
	      i,
	      idMap = ga.idMap || {},
	      storeAr = ga.storeAr || [],
	      nStoreArr = [],
	      yAxis = canvas.composition.yAxis;
	    // Changing y Axis formattor
	    debugger;
	    if (mode === 'reset') {
	      yAxis.getScaleObj().getIntervalObj().getConfig('intervals').major.formatter = function (val) {
	        return val;
	      };
	    } else {
	      yAxis.getScaleObj().getIntervalObj().getConfig('intervals').major.formatter = function (val) {
	        return val + '%';
	      };
	    }
	    // Declaration ends
	    this.ga = ga;
	    if (!ga.storeAr) {
	      store = {};
	      if (!ga.idMap) {
	        ds.forEachSeries(function (a, b, c, series) {
	          store[series.getId()] = series.getOriginalData();
	        });
	        for (i in store) {
	          storeAr.push(store[i]);
	          idMap[i] = storeAr.length - 1;
	          // = store[i].map(function (e) { return 20 * e + (Math.random() * 1000); });
	        }
	        ga.idMap = idMap;
	        ga.ds = ds;
	        ga.storeAr = storeAr;
	        ga.gAnalyser = new GrowthAnalyser(storeAr);
	      }
	    }
	    nStoreArr = ga.gAnalyser.analyse(mode);
	    ds.setDataBySeries(function (series) {
	      if (nStoreArr.length) {
	        series.setOriginalData(nStoreArr[idMap[series.getId()]]);
	      }
	    });
	    comp.impl.update();
	  };
	
	  LegendExt.prototype.init = function (require) {
	    var instance = this;
	    require([
	      'xAxis',
	      'yAxis',
	      'graphics',
	      'chart',
	      'dataset',
	      'PlotManager',
	      'canvasConfig',
	      'MarkerManager',
	      'reactiveModel',
	      'globalReactiveModel',
	      'spaceManagerInstance',
	      'smartLabel',
	      'chartInstance',
	      'canvasData',
	      function (
	            xAxis,
	            yAxis,
	            graphics,
	            chart,
	            dataset,
	            plotManager,
	            canvasConfig,
	            markerManager,
	            reactiveModel,
	            globalReactiveModel,
	            spaceManagerInstance,
	            smartLabel,
	            chartInstance,
	            canvasData) {
	        instance.xAxis = xAxis;
	        instance.yAxis = yAxis;
	        instance.graphics = graphics;
	        instance.chart = chart;
	        instance.dataset = dataset;
	        instance.plotManager = plotManager;
	        instance.markerManager = markerManager;
	        instance.canvasConfig = canvasConfig;
	        instance.reactiveModel = reactiveModel;
	        instance.globalReactiveModel = globalReactiveModel;
	        instance.spaceManagerInstance = spaceManagerInstance;
	        instance.smartLabel = smartLabel;
	        instance.chartInstance = chartInstance;
	        instance.canvasData = canvasData;
	      }
	    ]);
	    this.spaceManagerInstance = instance.spaceManagerInstance;
	    this.globalReactiveModel = instance.globalReactiveModel;
	    this.tsObject = instance.chartInstance;
	    this.startDt = instance.globalReactiveModel.model['x-axis-visible-range-start'];
	    this.endDt = instance.globalReactiveModel.model['x-axis-visible-range-end'];
	    this.startDataset = instance.globalReactiveModel.model['x-axis-absolute-range-start'];
	    this.endDataset = instance.globalReactiveModel.model['x-axis-absolute-range-end'];
	    this.toolbars = [];
	    this.measurement = {};
	    this.toolbars.push(this.createToolbar());
	    return this;
	  };
	
	  LegendExt.prototype.createToolbar = function () {
	    var toolbar,
	      group,
	      self = this,
	      contextMenu,
	      contextArray = [],
	      gaOptionsObj = {},
	      popup,
	      paper = this.graphics.paper,
	      chartContainer = this.graphics.container,
	      subCatStyle = {
	        'font-size': '12px',
	        'color': '#696969'
	      };
	
	    toolbar = new this.HorizontalToolbar({
	      paper: this.graphics.paper,
	      chart: this.chart,
	      smartLabel: this.smartLabel,
	      chartContainer: this.graphics.container
	    });
	
	    toolbar.setConfig({
	      fill: '#fff',
	      borderThickness: 0
	    });
	
	    group = new this.toolbox.ComponentGroup({
	      paper: this.graphics.paper,
	      chart: this.chart,
	      smartLabel: this.smartLabel,
	      chartContainer: this.graphics.container
	    });
	
	    group.setConfig({
	      fill: '#fff',
	      borderThickness: 0
	    });
	
	    gaOptionsObj = {
	      'Fixed-Number': 'dialogBox',
	      'Functions': ['Minimum', 'Maximum', 'Mean', 'Median', 'Standard Deviation'],
	      'Position': 'dialogBox',
	      'Dataset': ['Previous Dataset', 'Next Dataset'],
	      'Relative-Position': ['Next', 'Previous']
	    };
	
	    contextMenu = new this.toolbox.SymbolWithContext('ContextIcon', {
	      paper: this.graphics.paper,
	      chart: this.chart,
	      smartLabel: this.smartLabel,
	      chartContainer: this.graphics.container
	    }, {
	      width: 23,
	      height: 23,
	      position: 'right',
	      stroke: '#ced5d4',
	      symbolStroke: '#696969'
	    });
	
	    contextArray.push({
	      'Growth Analyser': {
	        style: {
	          'color': '#696969',
	          'font-family': 'MyriadPro',
	          'font-weight': 'bold'
	        }
	      }
	    });
	    popup = function (callback) {
	      var box,
	        header,
	        style = {
	          fontSize: 10 + 'px',
	          lineHeight: 15 + 'px',
	          fontFamily: 'Lucida Grande',
	          stroke: '#676767',
	          'stroke-width': '2'
	        },
	        headerWidth = 180,
	        headerText,
	        cross,
	        inputField,
	        applyButton,
	        x = 500,
	        y = 100;
	
	      box = paper.html('div', {
	        fill: '#f7f7f7',
	        x: x - 200,
	        y: y + 100,
	        width: 180,
	        height: 80
	      }, style, chartContainer);
	
	      header = paper.html('div', {
	        fill: '#e8e8e8',
	        width: headerWidth,
	        height: 20
	      }, style, box);
	
	      headerText = paper.html('div', {
	        fill: 'transparent',
	        width: headerWidth * 0.6,
	        height: 20,
	        x: 10,
	        y: 2
	      }, style, header);
	
	      headerText.attr({
	        text: 'Provide Specific Value'
	      });
	
	      cross = paper.html('div', {
	        fill: 'transparent',
	        width: 10,
	        height: 10,
	        position: 'relative',
	        float: 'right',
	        text: 'X',
	        cursor: 'pointer'
	      }, style, header);
	
	      cross.on('click', function () {
	        box.hide();
	      });
	
	      inputField = paper.html('input', {
	        width: 100,
	        height: 20,
	        x: 10,
	        y: 30
	      }, style, box);
	
	      applyButton = paper.html('div', {
	        width: 50,
	        height: 20,
	        x: 120,
	        y: 30,
	        fill: '#555555'
	      }, {
	        fontSize: 10 + 'px',
	        lineHeight: 15 + 'px',
	        fontFamily: 'Lucida Grande',
	        fill: '#eaeaea',
	        color: '#eaeaea',
	        stroke: '#eaeaea',
	        cursor: 'pointer'
	      }, box);
	
	      applyButton.on('click', function () {
	        box.hide();
	        callback(inputField.val());
	      });
	      applyButton.attr({
	        text: 'Apply'
	      });
	      inputField.element.focus();
	      function inputFieldNumberHandler () {
	        inputField.element.value = inputField.element.value.replace(/[^\d.-]/g, '');
	      }
	      inputField.element.addEventListener('keyup', inputFieldNumberHandler);
	      cross.element.style['position'] = 'relative';
	      cross.element.style['backgroundColor'] = '#d2d2d2';
	      cross.element.style['border'] = '2px solid #cbcbcb';
	      cross.element.style['padding'] = '0px 0px 3.5px 2px';
	      cross.element.style['color'] = '#8c8c8c';
	      cross.element.style['margin'] = '1px 2px';
	      cross.element.style['float'] = 'right';
	      inputField.element.style['marginTop'] = '8px';
	      inputField.element.style['border'] = '2px solid #dadbda';
	      applyButton.element.style['marginTop'] = '8px';
	      box.element.style['border'] = '1px solid #d4d2d3';
	      header.element.style['border'] = '1px solid #d4d2d3';
	      header.element.style['width'] = '179px';
	      headerText.element.style['fontSize'] = '11.5px';
	      headerText.element.style['marginTop'] = '0.5px';
	      headerText.element.style['color'] = '#676767';
	      header.element.style['fontFamily'] = 'MyriadPro';
	      applyButton.element.style['textAlign'] = 'center';
	      applyButton.element.style['fontSize'] = '11px';
	      applyButton.element.style['paddingTop'] = '3px';
	      applyButton.element.style['borderRadius'] = '3px';
	      applyButton.element.style['color'] = '#e4e4e4';
	    };
	
	    for (let i in gaOptionsObj) {
	      let key,
	        obj = {},
	        subObj = {};
	      if (gaOptionsObj[i] === 'dialogBox') {
	        key = '&nbsp; &nbsp; ' + i;
	        obj[key] = {};
	        obj[key] = {
	          style: subCatStyle,
	          handler: function () {
	            // let popupVal = popup(function (str) {
	            //   self.analyser(parseInt(str));
	            // });
	            if (i === 'Fixed-Number') {
	              // self.analyser(parseInt(window.prompt('Enter value')));
	              let popupVal = popup(function (str) {
	                self.analyser(parseInt(str));
	              });
	            } else if (i === 'Position') {
	              let popupVal = popup(function (str) {
	                self.analyser({position: str});
	              });
	            }
	          },
	          action: 'click'
	        };
	      } else {
	        key = '&#9666&nbsp; ' + i;
	        obj[key] = {};
	        obj[key].action = 'click';
	        obj[key].style = subCatStyle;
	        obj[key].handler = [];
	        for (let j = 0; j < gaOptionsObj[i].length; j++) {
	          let subMenuName = gaOptionsObj[i][j];
	          subObj = {};
	          subObj['&nbsp;' + subMenuName] = {};
	          subObj['&nbsp;' + subMenuName].handler = function () {
	            // ['Minimum', 'Maximum', 'Mean', 'Median', 'Standard Deviation']
	            // ['Previous Dataset', 'Next Dataset']
	            // ['Next', 'Previous']
	            if (subMenuName === 'Minimum' ||
	              subMenuName === 'Maximum' || subMenuName === 'Mean' ||
	              subMenuName === 'Median' || subMenuName === 'Standard Deviation') {
	              self.analyser(subMenuName);
	            } else if (subMenuName === 'Previous Dataset') {
	              self.analyser({reldatasetposition: -1});
	            } else if (subMenuName === 'Next Dataset') {
	              self.analyser({reldatasetposition: 1});
	            } else if (subMenuName === 'Next') {
	              self.analyser({relposition: -1});
	            } else if (subMenuName === 'Previous') {
	              self.analyser({relposition: 1});
	            }
	          };
	          subObj['&nbsp;' + subMenuName].action = 'click';
	          subObj['&nbsp;' + subMenuName].style = subCatStyle;
	          obj[key].handler.push(subObj);
	          if (j !== gaOptionsObj[i].length - 1) {
	            obj[key].handler.push({
	              '': {
	                style: {
	                  backgroundColor: '#d5d2d2',
	                  height: '1px',
	                  margin: '1px',
	                  padding: '0px'
	                }
	              }
	            });
	          }
	        }
	      }
	      contextArray.push(obj);
	      contextArray.push({
	        '': {
	          style: {
	            backgroundColor: '#d5d2d2',
	            height: '1px',
	            margin: '1px',
	            padding: '0px'
	          }
	        }
	      });
	    }
	
	    contextArray.push({
	      '&nbsp; &nbsp; Reset': {
	        handler: function () {
	          self.analyser('reset');
	        },
	        action: 'click',
	        style: subCatStyle
	      }
	    });
	
	    contextMenu.appendAsList(contextArray);
	
	    this.SymbolStore.register('ContextIcon', function (posx, posy, rad) {
	      var x = posx,
	        y = posy,
	        r = rad * 2,
	        space = Math.round(r / 4),
	        halfWidth = Math.round(r / 2) * 0.7,
	        startX = (x - halfWidth),
	        endX = (x + halfWidth),
	        startY = (y + space),
	        endY = (y - space);
	      return ['M', startX, y, 'L', endX, y, 'M', startX, startY, 'L', endX, startY, 'M', startX, endY, 'L', endX, endY];
	    });
	
	    group.addSymbol(contextMenu);
	    toolbar.addComponent(group);
	    return toolbar;
	  };
	
	  LegendExt.prototype.getLogicalSpace = function (availableWidth, availableHeight) {
	    availableWidth /= 2;
	    var logicalSpace,
	      width = 0,
	      height = 0,
	      i,
	      ln;
	
	    for (i = 0, ln = this.toolbars.length; i < ln; i++) {
	      logicalSpace = this.toolbars[i].getLogicalSpace(availableWidth, availableHeight);
	      width = Math.max(logicalSpace.width, width);
	      height += logicalSpace.height;
	      this.toolbars[i].width = logicalSpace.width;
	      this.toolbars[i].height = logicalSpace.height;
	    }
	    height += this.padding;
	    return {
	      width: width > availableWidth ? 0 : width,
	      height: height > availableHeight ? 0 : height
	    };
	  };
	
	  LegendExt.prototype.placeInCanvas = function () {
	    var self = this;
	    self.padding = 5;
	    self.spaceManagerInstance.add([{
	      name: function () {
	        return 'ToolBoxExt';
	      },
	      ref: function (obj) {
	        return obj['0'];
	      },
	      self: function () {
	        return self;
	      },
	      priority: function () {
	        return 2;
	      },
	      layout: function (obj) {
	        return obj.inline;
	      },
	      orientation: [{
	        type: function (obj) {
	          return obj.horizontal;
	        },
	        position: [{
	          type: function (obj) {
	            return obj.top;
	          },
	          alignment: [{
	            type: function (obj) {
	              return obj.right;
	            },
	            dimensions: [function () {
	              var parent = this.getParentComponentGroup();
	              return self.getLogicalSpace(parent.getWidth(), parent.getHeight());
	            }]
	          }]
	        }]
	      }]
	    }]);
	  };
	
	  LegendExt.prototype.setDrawingConfiguration = function (x, y, width, height, group) {
	    var mes = this.measurement;
	    mes.x = x;
	    mes.y = y;
	    mes.width = width;
	    mes.height = height;
	
	    this.parentGroup = group;
	
	    return this;
	  };
	
	  LegendExt.prototype.draw = function (x, y, width, height, group) {
	    var measurement = this.measurement,
	      toolbars = this.toolbars,
	      ln,
	      i,
	      toolbar;
	    x = x === undefined ? measurement.x : x;
	    y = y === undefined ? measurement.y : y;
	    width = width === undefined ? measurement.width : width;
	    height = height === undefined ? measurement.height : height;
	    group = group === undefined ? this.parentGroup : group;
	    if (width && height) {
	      for (i = 0, ln = toolbars.length; i < ln; i++) {
	        toolbar = toolbars[i];
	        toolbar.draw(x, y);
	      }
	    }
	  };
	
	  FusionCharts.registerComponent('extensions', 'legendExt', LegendExt);
	}]);


/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';
	class GrowthAnalyser {
	  constructor (data) {
	    this.data = data.map((a) => {
	      return a.map((b) => { return b; });
	    });
	    this.Formulae = Formulae;
	  }
	  analyse (mode) {
	    let i = 0,
	      ii = 0,
	      j = 0,
	      jj = 0,
	      num = 0,
	      checkArr = [],
	      checkNum = 0,
	      dataAr = this.data,
	      nDataAr = [],
	      tempAr = [],
	      temp = 0;
	    if (typeof mode === 'string' && mode.toLowerCase() === 'reset') {
	      return dataAr.map((a) => {
	        return a.map((b) => { return b; });
	      });
	    } else if (!isNaN(mode)) { // Handling a number
	      checkNum = +mode;
	      for (i = 0, ii = dataAr.length; i < ii; ++i) {
	        tempAr = [];
	        for (j = 0, jj = dataAr[i].length; j < jj; ++j) {
	          num = dataAr[i][j];
	          tempAr.push(100 * (num - checkNum) / checkNum);
	        }
	        nDataAr.push(tempAr);
	      }
	    } else if (typeof mode === 'string') {
	      mode = this.Formulae[mode];
	      for (i = 0, ii = dataAr.length; i < ii; ++i) {
	        tempAr = [];
	        checkNum = mode(dataAr[i]);
	        for (j = 0, jj = dataAr[i].length; j < jj; ++j) {
	          num = dataAr[i][j];
	          if (checkNum === 0) {
	            temp = undefined;
	          } else {
	            temp = 100 * (num - checkNum) / checkNum;
	          }
	          tempAr.push(temp);
	        }
	        nDataAr.push(tempAr);
	      }
	    } else if (!isNaN(mode.relposition)) {
	      mode = mode.relposition;
	      for (i = 0, ii = dataAr.length; i < ii; ++i) {
	        tempAr = [];
	        for (j = 0, jj = dataAr[i].length; j < jj; ++j) {
	          num = dataAr[i][j];
	          if (j + mode >= 0 && j + mode < jj) {
	            checkNum = dataAr[i][j + mode];
	          } else {
	            checkNum = num;
	          }
	          tempAr.push(100 * (num - checkNum) / checkNum);
	        }
	        nDataAr.push(tempAr);
	      }
	    } else if (!isNaN(mode.position)) {
	      mode = mode.position;
	      for (i = 0, ii = dataAr.length; i < ii; ++i) {
	        tempAr = [];
	        for (j = 0, jj = dataAr[i].length; j < jj; ++j) {
	          num = dataAr[i][j];
	          if (mode >= 0 && mode < jj) {
	            checkNum = dataAr[i][mode];
	          } else {
	            checkNum = num;
	          }
	          tempAr.push(100 * (num - checkNum) / checkNum);
	        }
	        nDataAr.push(tempAr);
	      }
	    } else if (!isNaN(mode.reldatasetposition)) {
	      mode = mode.reldatasetposition;
	      for (i = 0, ii = dataAr.length; i < ii; ++i) {
	        tempAr = [];
	        if (i + mode >= 0 && i + mode < ii) {
	          checkArr = dataAr[i + mode];
	        } else {
	          checkArr = dataAr[i];
	        }
	        for (j = 0, jj = dataAr[i].length; j < jj; ++j) {
	          checkNum = checkArr[j];
	          num = dataAr[i][j];
	          tempAr.push(100 * (num - checkNum) / num);
	        }
	        nDataAr.push(tempAr);
	      }
	    }
	    for (i = 0, ii = nDataAr.length; i < ii; ++i) {
	      for (j = 0, jj = nDataAr[i].length; j < jj; ++j) {
	        if (!Number.isFinite(nDataAr[i][j])) {
	          nDataAr[i][j] = null;
	        }
	      }
	    }
	    return nDataAr;
	  }
	}
	
	var Formulae = {
	  Minimum: (arr) => {
	    return arr.reduce((a, b) => {
	      return a > b ? b : a;
	    });
	  },
	  Maximum: (arr) => {
	    return arr.reduce((a, b) => {
	      return a < b ? b : a;
	    });
	  },
	  Mean: (arr) => {
	    return arr.reduce((a, b) => {
	      return a + b;
	    }) / arr.length;
	  },
	  Median: (arr) => {
	    return arr.map((a) => a).sort((a, b) => { return a - b; })[arr.length / 2];
	  },
	  'Standard Deviation': (values) => {
	    function average (data) {
	      var sum, avg;
	      sum = data.reduce(function (sum, value) {
	        return sum + value;
	      }, 0);
	
	      avg = sum / data.length;
	      return avg;
	    }
	    var avg = 0,
	      squareDiffs = 0,
	      sqrDiff = 0,
	      avgSquareDiff = 0,
	      stdDev = 0,
	      diff = 0;
	    avg = average(values);
	    squareDiffs = values.map(function (value) {
	      diff = value - avg;
	      sqrDiff = diff * diff;
	      return sqrDiff;
	    });
	    avgSquareDiff = average(squareDiffs);
	    stdDev = Math.sqrt(avgSquareDiff);
	    return stdDev;
	  }
	};
	
	module.exports = GrowthAnalyser;


/***/ }
/******/ ]);

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMmI0NjYyMmRlMjk4MTI1NzYxMzEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4dGVuc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ3Jvd3RoYW5hbHlzZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdENBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEMsd0NBQXdDLEVBQUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtB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Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgMmI0NjYyMmRlMjk4MTI1NzYxMzEiLCJjb25zdCBHcm93dGhBbmFseXNlciA9IHJlcXVpcmUoJy4vZ3Jvd3RoYW5hbHlzZXInKTtcblxuRnVzaW9uQ2hhcnRzLnJlZ2lzdGVyKCdleHRlbnNpb24nLCBbJ3ByaXZhdGUnLCAnbGVnZW5kLWV4dCcsIGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGVnZW5kRXh0ICgpIHtcbiAgICB0aGlzLnRvb2xib3ggPSBGdXNpb25DaGFydHMuZ2V0Q29tcG9uZW50KCdhcGknLCAndG9vbGJveCcpO1xuICAgIHRoaXMuSG9yaXpvbnRhbFRvb2xiYXIgPSB0aGlzLnRvb2xib3guSG9yaXpvbnRhbFRvb2xiYXI7XG4gICAgdGhpcy5Db21wb25lbnRHcm91cCA9IHRoaXMudG9vbGJveC5Db21wb25lbnRHcm91cDtcbiAgICB0aGlzLlN5bWJvbFN0b3JlID0gdGhpcy50b29sYm94LlN5bWJvbFN0b3JlO1xuICB9XG4gIExlZ2VuZEV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMZWdlbmRFeHQ7XG5cbiAgTGVnZW5kRXh0LnByb3RvdHlwZS5yZW5kZXJDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNoYXJ0SW5zdGFuY2UgPSB0aGlzLnRzT2JqZWN0LmNoYXJ0SW5zdGFuY2UsXG4gICAgICBjb21wb25lbnRTdG9yZSA9IGNoYXJ0SW5zdGFuY2UuYXBpSW5zdGFuY2UuZ2V0Q29tcG9uZW50U3RvcmUoKSxcbiAgICAgIGkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGNvbXBvbmVudFN0b3JlLmdldENhbnZhc0J5SW5kZXgoaSk7ICsraSkge1xuICAgICAgY29tcG9uZW50U3RvcmUuZ2V0Q2FudmFzQnlJbmRleChpKS5nZXRDb21wb3NpdGlvbigpLlBsb3RNYW5hZ2VyLnBsb3QoKTtcbiAgICB9XG4gIH07XG5cbiAgTGVnZW5kRXh0LnByb3RvdHlwZS5hbmFseXNlciA9IGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgdmFyIGdhID0gdGhpcy5nYSB8fCB7fSxcbiAgICAgIHN0b3JlID0gdGhpcy50c09iamVjdC5hcGlJbnN0YW5jZS5nZXRDb21wb25lbnRTdG9yZSgpLFxuICAgICAgY2FudmFzID0gc3RvcmUuZ2V0Q2FudmFzQnlJbmRleCgwKSxcbiAgICAgIG5hdiA9IHN0b3JlLmdldE5hdmlnYXRvckJ5SW5kZXgoMCksXG4gICAgICBjb21wID0gY2FudmFzLmdldENvbXBvc2l0aW9uKCksXG4gICAgICBkcyA9IGdhLmRzIHx8IGNvbXAuZGF0YXNldCxcbiAgICAgIGksXG4gICAgICBpZE1hcCA9IGdhLmlkTWFwIHx8IHt9LFxuICAgICAgc3RvcmVBciA9IGdhLnN0b3JlQXIgfHwgW10sXG4gICAgICBuU3RvcmVBcnIgPSBbXSxcbiAgICAgIHlBeGlzID0gY2FudmFzLmNvbXBvc2l0aW9uLnlBeGlzO1xuICAgIC8vIENoYW5naW5nIHkgQXhpcyBmb3JtYXR0b3JcbiAgICBkZWJ1Z2dlcjtcbiAgICBpZiAobW9kZSA9PT0gJ3Jlc2V0Jykge1xuICAgICAgeUF4aXMuZ2V0U2NhbGVPYmooKS5nZXRJbnRlcnZhbE9iaigpLmdldENvbmZpZygnaW50ZXJ2YWxzJykubWFqb3IuZm9ybWF0dGVyID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgeUF4aXMuZ2V0U2NhbGVPYmooKS5nZXRJbnRlcnZhbE9iaigpLmdldENvbmZpZygnaW50ZXJ2YWxzJykubWFqb3IuZm9ybWF0dGVyID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsICsgJyUnO1xuICAgICAgfTtcbiAgICB9XG4gICAgLy8gRGVjbGFyYXRpb24gZW5kc1xuICAgIHRoaXMuZ2EgPSBnYTtcbiAgICBpZiAoIWdhLnN0b3JlQXIpIHtcbiAgICAgIHN0b3JlID0ge307XG4gICAgICBpZiAoIWdhLmlkTWFwKSB7XG4gICAgICAgIGRzLmZvckVhY2hTZXJpZXMoZnVuY3Rpb24gKGEsIGIsIGMsIHNlcmllcykge1xuICAgICAgICAgIHN0b3JlW3Nlcmllcy5nZXRJZCgpXSA9IHNlcmllcy5nZXRPcmlnaW5hbERhdGEoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoaSBpbiBzdG9yZSkge1xuICAgICAgICAgIHN0b3JlQXIucHVzaChzdG9yZVtpXSk7XG4gICAgICAgICAgaWRNYXBbaV0gPSBzdG9yZUFyLmxlbmd0aCAtIDE7XG4gICAgICAgICAgLy8gPSBzdG9yZVtpXS5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIDIwICogZSArIChNYXRoLnJhbmRvbSgpICogMTAwMCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGdhLmlkTWFwID0gaWRNYXA7XG4gICAgICAgIGdhLmRzID0gZHM7XG4gICAgICAgIGdhLnN0b3JlQXIgPSBzdG9yZUFyO1xuICAgICAgICBnYS5nQW5hbHlzZXIgPSBuZXcgR3Jvd3RoQW5hbHlzZXIoc3RvcmVBcik7XG4gICAgICB9XG4gICAgfVxuICAgIG5TdG9yZUFyciA9IGdhLmdBbmFseXNlci5hbmFseXNlKG1vZGUpO1xuICAgIGRzLnNldERhdGFCeVNlcmllcyhmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgICBpZiAoblN0b3JlQXJyLmxlbmd0aCkge1xuICAgICAgICBzZXJpZXMuc2V0T3JpZ2luYWxEYXRhKG5TdG9yZUFycltpZE1hcFtzZXJpZXMuZ2V0SWQoKV1dKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb21wLmltcGwudXBkYXRlKCk7XG4gIH07XG5cbiAgTGVnZW5kRXh0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB0aGlzO1xuICAgIHJlcXVpcmUoW1xuICAgICAgJ3hBeGlzJyxcbiAgICAgICd5QXhpcycsXG4gICAgICAnZ3JhcGhpY3MnLFxuICAgICAgJ2NoYXJ0JyxcbiAgICAgICdkYXRhc2V0JyxcbiAgICAgICdQbG90TWFuYWdlcicsXG4gICAgICAnY2FudmFzQ29uZmlnJyxcbiAgICAgICdNYXJrZXJNYW5hZ2VyJyxcbiAgICAgICdyZWFjdGl2ZU1vZGVsJyxcbiAgICAgICdnbG9iYWxSZWFjdGl2ZU1vZGVsJyxcbiAgICAgICdzcGFjZU1hbmFnZXJJbnN0YW5jZScsXG4gICAgICAnc21hcnRMYWJlbCcsXG4gICAgICAnY2hhcnRJbnN0YW5jZScsXG4gICAgICAnY2FudmFzRGF0YScsXG4gICAgICBmdW5jdGlvbiAoXG4gICAgICAgICAgICB4QXhpcyxcbiAgICAgICAgICAgIHlBeGlzLFxuICAgICAgICAgICAgZ3JhcGhpY3MsXG4gICAgICAgICAgICBjaGFydCxcbiAgICAgICAgICAgIGRhdGFzZXQsXG4gICAgICAgICAgICBwbG90TWFuYWdlcixcbiAgICAgICAgICAgIGNhbnZhc0NvbmZpZyxcbiAgICAgICAgICAgIG1hcmtlck1hbmFnZXIsXG4gICAgICAgICAgICByZWFjdGl2ZU1vZGVsLFxuICAgICAgICAgICAgZ2xvYmFsUmVhY3RpdmVNb2RlbCxcbiAgICAgICAgICAgIHNwYWNlTWFuYWdlckluc3RhbmNlLFxuICAgICAgICAgICAgc21hcnRMYWJlbCxcbiAgICAgICAgICAgIGNoYXJ0SW5zdGFuY2UsXG4gICAgICAgICAgICBjYW52YXNEYXRhKSB7XG4gICAgICAgIGluc3RhbmNlLnhBeGlzID0geEF4aXM7XG4gICAgICAgIGluc3RhbmNlLnlBeGlzID0geUF4aXM7XG4gICAgICAgIGluc3RhbmNlLmdyYXBoaWNzID0gZ3JhcGhpY3M7XG4gICAgICAgIGluc3RhbmNlLmNoYXJ0ID0gY2hhcnQ7XG4gICAgICAgIGluc3RhbmNlLmRhdGFzZXQgPSBkYXRhc2V0O1xuICAgICAgICBpbnN0YW5jZS5wbG90TWFuYWdlciA9IHBsb3RNYW5hZ2VyO1xuICAgICAgICBpbnN0YW5jZS5tYXJrZXJNYW5hZ2VyID0gbWFya2VyTWFuYWdlcjtcbiAgICAgICAgaW5zdGFuY2UuY2FudmFzQ29uZmlnID0gY2FudmFzQ29uZmlnO1xuICAgICAgICBpbnN0YW5jZS5yZWFjdGl2ZU1vZGVsID0gcmVhY3RpdmVNb2RlbDtcbiAgICAgICAgaW5zdGFuY2UuZ2xvYmFsUmVhY3RpdmVNb2RlbCA9IGdsb2JhbFJlYWN0aXZlTW9kZWw7XG4gICAgICAgIGluc3RhbmNlLnNwYWNlTWFuYWdlckluc3RhbmNlID0gc3BhY2VNYW5hZ2VySW5zdGFuY2U7XG4gICAgICAgIGluc3RhbmNlLnNtYXJ0TGFiZWwgPSBzbWFydExhYmVsO1xuICAgICAgICBpbnN0YW5jZS5jaGFydEluc3RhbmNlID0gY2hhcnRJbnN0YW5jZTtcbiAgICAgICAgaW5zdGFuY2UuY2FudmFzRGF0YSA9IGNhbnZhc0RhdGE7XG4gICAgICB9XG4gICAgXSk7XG4gICAgdGhpcy5zcGFjZU1hbmFnZXJJbnN0YW5jZSA9IGluc3RhbmNlLnNwYWNlTWFuYWdlckluc3RhbmNlO1xuICAgIHRoaXMuZ2xvYmFsUmVhY3RpdmVNb2RlbCA9IGluc3RhbmNlLmdsb2JhbFJlYWN0aXZlTW9kZWw7XG4gICAgdGhpcy50c09iamVjdCA9IGluc3RhbmNlLmNoYXJ0SW5zdGFuY2U7XG4gICAgdGhpcy5zdGFydER0ID0gaW5zdGFuY2UuZ2xvYmFsUmVhY3RpdmVNb2RlbC5tb2RlbFsneC1heGlzLXZpc2libGUtcmFuZ2Utc3RhcnQnXTtcbiAgICB0aGlzLmVuZER0ID0gaW5zdGFuY2UuZ2xvYmFsUmVhY3RpdmVNb2RlbC5tb2RlbFsneC1heGlzLXZpc2libGUtcmFuZ2UtZW5kJ107XG4gICAgdGhpcy5zdGFydERhdGFzZXQgPSBpbnN0YW5jZS5nbG9iYWxSZWFjdGl2ZU1vZGVsLm1vZGVsWyd4LWF4aXMtYWJzb2x1dGUtcmFuZ2Utc3RhcnQnXTtcbiAgICB0aGlzLmVuZERhdGFzZXQgPSBpbnN0YW5jZS5nbG9iYWxSZWFjdGl2ZU1vZGVsLm1vZGVsWyd4LWF4aXMtYWJzb2x1dGUtcmFuZ2UtZW5kJ107XG4gICAgdGhpcy50b29sYmFycyA9IFtdO1xuICAgIHRoaXMubWVhc3VyZW1lbnQgPSB7fTtcbiAgICB0aGlzLnRvb2xiYXJzLnB1c2godGhpcy5jcmVhdGVUb29sYmFyKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIExlZ2VuZEV4dC5wcm90b3R5cGUuY3JlYXRlVG9vbGJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdG9vbGJhcixcbiAgICAgIGdyb3VwLFxuICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICBjb250ZXh0TWVudSxcbiAgICAgIGNvbnRleHRBcnJheSA9IFtdLFxuICAgICAgZ2FPcHRpb25zT2JqID0ge30sXG4gICAgICBwb3B1cCxcbiAgICAgIHBhcGVyID0gdGhpcy5ncmFwaGljcy5wYXBlcixcbiAgICAgIGNoYXJ0Q29udGFpbmVyID0gdGhpcy5ncmFwaGljcy5jb250YWluZXIsXG4gICAgICBzdWJDYXRTdHlsZSA9IHtcbiAgICAgICAgJ2ZvbnQtc2l6ZSc6ICcxMnB4JyxcbiAgICAgICAgJ2NvbG9yJzogJyM2OTY5NjknXG4gICAgICB9O1xuXG4gICAgdG9vbGJhciA9IG5ldyB0aGlzLkhvcml6b250YWxUb29sYmFyKHtcbiAgICAgIHBhcGVyOiB0aGlzLmdyYXBoaWNzLnBhcGVyLFxuICAgICAgY2hhcnQ6IHRoaXMuY2hhcnQsXG4gICAgICBzbWFydExhYmVsOiB0aGlzLnNtYXJ0TGFiZWwsXG4gICAgICBjaGFydENvbnRhaW5lcjogdGhpcy5ncmFwaGljcy5jb250YWluZXJcbiAgICB9KTtcblxuICAgIHRvb2xiYXIuc2V0Q29uZmlnKHtcbiAgICAgIGZpbGw6ICcjZmZmJyxcbiAgICAgIGJvcmRlclRoaWNrbmVzczogMFxuICAgIH0pO1xuXG4gICAgZ3JvdXAgPSBuZXcgdGhpcy50b29sYm94LkNvbXBvbmVudEdyb3VwKHtcbiAgICAgIHBhcGVyOiB0aGlzLmdyYXBoaWNzLnBhcGVyLFxuICAgICAgY2hhcnQ6IHRoaXMuY2hhcnQsXG4gICAgICBzbWFydExhYmVsOiB0aGlzLnNtYXJ0TGFiZWwsXG4gICAgICBjaGFydENvbnRhaW5lcjogdGhpcy5ncmFwaGljcy5jb250YWluZXJcbiAgICB9KTtcblxuICAgIGdyb3VwLnNldENvbmZpZyh7XG4gICAgICBmaWxsOiAnI2ZmZicsXG4gICAgICBib3JkZXJUaGlja25lc3M6IDBcbiAgICB9KTtcblxuICAgIGdhT3B0aW9uc09iaiA9IHtcbiAgICAgICdGaXhlZC1OdW1iZXInOiAnZGlhbG9nQm94JyxcbiAgICAgICdGdW5jdGlvbnMnOiBbJ01pbmltdW0nLCAnTWF4aW11bScsICdNZWFuJywgJ01lZGlhbicsICdTdGFuZGFyZCBEZXZpYXRpb24nXSxcbiAgICAgICdQb3NpdGlvbic6ICdkaWFsb2dCb3gnLFxuICAgICAgJ0RhdGFzZXQnOiBbJ1ByZXZpb3VzIERhdGFzZXQnLCAnTmV4dCBEYXRhc2V0J10sXG4gICAgICAnUmVsYXRpdmUtUG9zaXRpb24nOiBbJ05leHQnLCAnUHJldmlvdXMnXVxuICAgIH07XG5cbiAgICBjb250ZXh0TWVudSA9IG5ldyB0aGlzLnRvb2xib3guU3ltYm9sV2l0aENvbnRleHQoJ0NvbnRleHRJY29uJywge1xuICAgICAgcGFwZXI6IHRoaXMuZ3JhcGhpY3MucGFwZXIsXG4gICAgICBjaGFydDogdGhpcy5jaGFydCxcbiAgICAgIHNtYXJ0TGFiZWw6IHRoaXMuc21hcnRMYWJlbCxcbiAgICAgIGNoYXJ0Q29udGFpbmVyOiB0aGlzLmdyYXBoaWNzLmNvbnRhaW5lclxuICAgIH0sIHtcbiAgICAgIHdpZHRoOiAyMyxcbiAgICAgIGhlaWdodDogMjMsXG4gICAgICBwb3NpdGlvbjogJ3JpZ2h0JyxcbiAgICAgIHN0cm9rZTogJyNjZWQ1ZDQnLFxuICAgICAgc3ltYm9sU3Ryb2tlOiAnIzY5Njk2OSdcbiAgICB9KTtcblxuICAgIGNvbnRleHRBcnJheS5wdXNoKHtcbiAgICAgICdHcm93dGggQW5hbHlzZXInOiB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgJ2NvbG9yJzogJyM2OTY5NjknLFxuICAgICAgICAgICdmb250LWZhbWlseSc6ICdNeXJpYWRQcm8nLFxuICAgICAgICAgICdmb250LXdlaWdodCc6ICdib2xkJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcG9wdXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBib3gsXG4gICAgICAgIGhlYWRlcixcbiAgICAgICAgc3R5bGUgPSB7XG4gICAgICAgICAgZm9udFNpemU6IDEwICsgJ3B4JyxcbiAgICAgICAgICBsaW5lSGVpZ2h0OiAxNSArICdweCcsXG4gICAgICAgICAgZm9udEZhbWlseTogJ0x1Y2lkYSBHcmFuZGUnLFxuICAgICAgICAgIHN0cm9rZTogJyM2NzY3NjcnLFxuICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAnMidcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZGVyV2lkdGggPSAxODAsXG4gICAgICAgIGhlYWRlclRleHQsXG4gICAgICAgIGNyb3NzLFxuICAgICAgICBpbnB1dEZpZWxkLFxuICAgICAgICBhcHBseUJ1dHRvbixcbiAgICAgICAgeCA9IDUwMCxcbiAgICAgICAgeSA9IDEwMDtcblxuICAgICAgYm94ID0gcGFwZXIuaHRtbCgnZGl2Jywge1xuICAgICAgICBmaWxsOiAnI2Y3ZjdmNycsXG4gICAgICAgIHg6IHggLSAyMDAsXG4gICAgICAgIHk6IHkgKyAxMDAsXG4gICAgICAgIHdpZHRoOiAxODAsXG4gICAgICAgIGhlaWdodDogODBcbiAgICAgIH0sIHN0eWxlLCBjaGFydENvbnRhaW5lcik7XG5cbiAgICAgIGhlYWRlciA9IHBhcGVyLmh0bWwoJ2RpdicsIHtcbiAgICAgICAgZmlsbDogJyNlOGU4ZTgnLFxuICAgICAgICB3aWR0aDogaGVhZGVyV2lkdGgsXG4gICAgICAgIGhlaWdodDogMjBcbiAgICAgIH0sIHN0eWxlLCBib3gpO1xuXG4gICAgICBoZWFkZXJUZXh0ID0gcGFwZXIuaHRtbCgnZGl2Jywge1xuICAgICAgICBmaWxsOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICB3aWR0aDogaGVhZGVyV2lkdGggKiAwLjYsXG4gICAgICAgIGhlaWdodDogMjAsXG4gICAgICAgIHg6IDEwLFxuICAgICAgICB5OiAyXG4gICAgICB9LCBzdHlsZSwgaGVhZGVyKTtcblxuICAgICAgaGVhZGVyVGV4dC5hdHRyKHtcbiAgICAgICAgdGV4dDogJ1Byb3ZpZGUgU3BlY2lmaWMgVmFsdWUnXG4gICAgICB9KTtcblxuICAgICAgY3Jvc3MgPSBwYXBlci5odG1sKCdkaXYnLCB7XG4gICAgICAgIGZpbGw6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgIHdpZHRoOiAxMCxcbiAgICAgICAgaGVpZ2h0OiAxMCxcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgIGZsb2F0OiAncmlnaHQnLFxuICAgICAgICB0ZXh0OiAnWCcsXG4gICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICB9LCBzdHlsZSwgaGVhZGVyKTtcblxuICAgICAgY3Jvc3Mub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBib3guaGlkZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGlucHV0RmllbGQgPSBwYXBlci5odG1sKCdpbnB1dCcsIHtcbiAgICAgICAgd2lkdGg6IDEwMCxcbiAgICAgICAgaGVpZ2h0OiAyMCxcbiAgICAgICAgeDogMTAsXG4gICAgICAgIHk6IDMwXG4gICAgICB9LCBzdHlsZSwgYm94KTtcblxuICAgICAgYXBwbHlCdXR0b24gPSBwYXBlci5odG1sKCdkaXYnLCB7XG4gICAgICAgIHdpZHRoOiA1MCxcbiAgICAgICAgaGVpZ2h0OiAyMCxcbiAgICAgICAgeDogMTIwLFxuICAgICAgICB5OiAzMCxcbiAgICAgICAgZmlsbDogJyM1NTU1NTUnXG4gICAgICB9LCB7XG4gICAgICAgIGZvbnRTaXplOiAxMCArICdweCcsXG4gICAgICAgIGxpbmVIZWlnaHQ6IDE1ICsgJ3B4JyxcbiAgICAgICAgZm9udEZhbWlseTogJ0x1Y2lkYSBHcmFuZGUnLFxuICAgICAgICBmaWxsOiAnI2VhZWFlYScsXG4gICAgICAgIGNvbG9yOiAnI2VhZWFlYScsXG4gICAgICAgIHN0cm9rZTogJyNlYWVhZWEnLFxuICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgfSwgYm94KTtcblxuICAgICAgYXBwbHlCdXR0b24ub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBib3guaGlkZSgpO1xuICAgICAgICBjYWxsYmFjayhpbnB1dEZpZWxkLnZhbCgpKTtcbiAgICAgIH0pO1xuICAgICAgYXBwbHlCdXR0b24uYXR0cih7XG4gICAgICAgIHRleHQ6ICdBcHBseSdcbiAgICAgIH0pO1xuICAgICAgaW5wdXRGaWVsZC5lbGVtZW50LmZvY3VzKCk7XG4gICAgICBmdW5jdGlvbiBpbnB1dEZpZWxkTnVtYmVySGFuZGxlciAoKSB7XG4gICAgICAgIGlucHV0RmllbGQuZWxlbWVudC52YWx1ZSA9IGlucHV0RmllbGQuZWxlbWVudC52YWx1ZS5yZXBsYWNlKC9bXlxcZC4tXS9nLCAnJyk7XG4gICAgICB9XG4gICAgICBpbnB1dEZpZWxkLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBpbnB1dEZpZWxkTnVtYmVySGFuZGxlcik7XG4gICAgICBjcm9zcy5lbGVtZW50LnN0eWxlWydwb3NpdGlvbiddID0gJ3JlbGF0aXZlJztcbiAgICAgIGNyb3NzLmVsZW1lbnQuc3R5bGVbJ2JhY2tncm91bmRDb2xvciddID0gJyNkMmQyZDInO1xuICAgICAgY3Jvc3MuZWxlbWVudC5zdHlsZVsnYm9yZGVyJ10gPSAnMnB4IHNvbGlkICNjYmNiY2InO1xuICAgICAgY3Jvc3MuZWxlbWVudC5zdHlsZVsncGFkZGluZyddID0gJzBweCAwcHggMy41cHggMnB4JztcbiAgICAgIGNyb3NzLmVsZW1lbnQuc3R5bGVbJ2NvbG9yJ10gPSAnIzhjOGM4Yyc7XG4gICAgICBjcm9zcy5lbGVtZW50LnN0eWxlWydtYXJnaW4nXSA9ICcxcHggMnB4JztcbiAgICAgIGNyb3NzLmVsZW1lbnQuc3R5bGVbJ2Zsb2F0J10gPSAncmlnaHQnO1xuICAgICAgaW5wdXRGaWVsZC5lbGVtZW50LnN0eWxlWydtYXJnaW5Ub3AnXSA9ICc4cHgnO1xuICAgICAgaW5wdXRGaWVsZC5lbGVtZW50LnN0eWxlWydib3JkZXInXSA9ICcycHggc29saWQgI2RhZGJkYSc7XG4gICAgICBhcHBseUJ1dHRvbi5lbGVtZW50LnN0eWxlWydtYXJnaW5Ub3AnXSA9ICc4cHgnO1xuICAgICAgYm94LmVsZW1lbnQuc3R5bGVbJ2JvcmRlciddID0gJzFweCBzb2xpZCAjZDRkMmQzJztcbiAgICAgIGhlYWRlci5lbGVtZW50LnN0eWxlWydib3JkZXInXSA9ICcxcHggc29saWQgI2Q0ZDJkMyc7XG4gICAgICBoZWFkZXIuZWxlbWVudC5zdHlsZVsnd2lkdGgnXSA9ICcxNzlweCc7XG4gICAgICBoZWFkZXJUZXh0LmVsZW1lbnQuc3R5bGVbJ2ZvbnRTaXplJ10gPSAnMTEuNXB4JztcbiAgICAgIGhlYWRlclRleHQuZWxlbWVudC5zdHlsZVsnbWFyZ2luVG9wJ10gPSAnMC41cHgnO1xuICAgICAgaGVhZGVyVGV4dC5lbGVtZW50LnN0eWxlWydjb2xvciddID0gJyM2NzY3NjcnO1xuICAgICAgaGVhZGVyLmVsZW1lbnQuc3R5bGVbJ2ZvbnRGYW1pbHknXSA9ICdNeXJpYWRQcm8nO1xuICAgICAgYXBwbHlCdXR0b24uZWxlbWVudC5zdHlsZVsndGV4dEFsaWduJ10gPSAnY2VudGVyJztcbiAgICAgIGFwcGx5QnV0dG9uLmVsZW1lbnQuc3R5bGVbJ2ZvbnRTaXplJ10gPSAnMTFweCc7XG4gICAgICBhcHBseUJ1dHRvbi5lbGVtZW50LnN0eWxlWydwYWRkaW5nVG9wJ10gPSAnM3B4JztcbiAgICAgIGFwcGx5QnV0dG9uLmVsZW1lbnQuc3R5bGVbJ2JvcmRlclJhZGl1cyddID0gJzNweCc7XG4gICAgICBhcHBseUJ1dHRvbi5lbGVtZW50LnN0eWxlWydjb2xvciddID0gJyNlNGU0ZTQnO1xuICAgIH07XG5cbiAgICBmb3IgKGxldCBpIGluIGdhT3B0aW9uc09iaikge1xuICAgICAgbGV0IGtleSxcbiAgICAgICAgb2JqID0ge30sXG4gICAgICAgIHN1Yk9iaiA9IHt9O1xuICAgICAgaWYgKGdhT3B0aW9uc09ialtpXSA9PT0gJ2RpYWxvZ0JveCcpIHtcbiAgICAgICAga2V5ID0gJyZuYnNwOyAmbmJzcDsgJyArIGk7XG4gICAgICAgIG9ialtrZXldID0ge307XG4gICAgICAgIG9ialtrZXldID0ge1xuICAgICAgICAgIHN0eWxlOiBzdWJDYXRTdHlsZSxcbiAgICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBsZXQgcG9wdXBWYWwgPSBwb3B1cChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICAvLyAgIHNlbGYuYW5hbHlzZXIocGFyc2VJbnQoc3RyKSk7XG4gICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgICAgIGlmIChpID09PSAnRml4ZWQtTnVtYmVyJykge1xuICAgICAgICAgICAgICAvLyBzZWxmLmFuYWx5c2VyKHBhcnNlSW50KHdpbmRvdy5wcm9tcHQoJ0VudGVyIHZhbHVlJykpKTtcbiAgICAgICAgICAgICAgbGV0IHBvcHVwVmFsID0gcG9wdXAoZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgICAgIHNlbGYuYW5hbHlzZXIocGFyc2VJbnQoc3RyKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpID09PSAnUG9zaXRpb24nKSB7XG4gICAgICAgICAgICAgIGxldCBwb3B1cFZhbCA9IHBvcHVwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmFuYWx5c2VyKHtwb3NpdGlvbjogc3RyfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYWN0aW9uOiAnY2xpY2snXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXkgPSAnJiM5NjY2Jm5ic3A7ICcgKyBpO1xuICAgICAgICBvYmpba2V5XSA9IHt9O1xuICAgICAgICBvYmpba2V5XS5hY3Rpb24gPSAnY2xpY2snO1xuICAgICAgICBvYmpba2V5XS5zdHlsZSA9IHN1YkNhdFN0eWxlO1xuICAgICAgICBvYmpba2V5XS5oYW5kbGVyID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZ2FPcHRpb25zT2JqW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgbGV0IHN1Yk1lbnVOYW1lID0gZ2FPcHRpb25zT2JqW2ldW2pdO1xuICAgICAgICAgIHN1Yk9iaiA9IHt9O1xuICAgICAgICAgIHN1Yk9ialsnJm5ic3A7JyArIHN1Yk1lbnVOYW1lXSA9IHt9O1xuICAgICAgICAgIHN1Yk9ialsnJm5ic3A7JyArIHN1Yk1lbnVOYW1lXS5oYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gWydNaW5pbXVtJywgJ01heGltdW0nLCAnTWVhbicsICdNZWRpYW4nLCAnU3RhbmRhcmQgRGV2aWF0aW9uJ11cbiAgICAgICAgICAgIC8vIFsnUHJldmlvdXMgRGF0YXNldCcsICdOZXh0IERhdGFzZXQnXVxuICAgICAgICAgICAgLy8gWydOZXh0JywgJ1ByZXZpb3VzJ11cbiAgICAgICAgICAgIGlmIChzdWJNZW51TmFtZSA9PT0gJ01pbmltdW0nIHx8XG4gICAgICAgICAgICAgIHN1Yk1lbnVOYW1lID09PSAnTWF4aW11bScgfHwgc3ViTWVudU5hbWUgPT09ICdNZWFuJyB8fFxuICAgICAgICAgICAgICBzdWJNZW51TmFtZSA9PT0gJ01lZGlhbicgfHwgc3ViTWVudU5hbWUgPT09ICdTdGFuZGFyZCBEZXZpYXRpb24nKSB7XG4gICAgICAgICAgICAgIHNlbGYuYW5hbHlzZXIoc3ViTWVudU5hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdWJNZW51TmFtZSA9PT0gJ1ByZXZpb3VzIERhdGFzZXQnKSB7XG4gICAgICAgICAgICAgIHNlbGYuYW5hbHlzZXIoe3JlbGRhdGFzZXRwb3NpdGlvbjogLTF9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3ViTWVudU5hbWUgPT09ICdOZXh0IERhdGFzZXQnKSB7XG4gICAgICAgICAgICAgIHNlbGYuYW5hbHlzZXIoe3JlbGRhdGFzZXRwb3NpdGlvbjogMX0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdWJNZW51TmFtZSA9PT0gJ05leHQnKSB7XG4gICAgICAgICAgICAgIHNlbGYuYW5hbHlzZXIoe3JlbHBvc2l0aW9uOiAtMX0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdWJNZW51TmFtZSA9PT0gJ1ByZXZpb3VzJykge1xuICAgICAgICAgICAgICBzZWxmLmFuYWx5c2VyKHtyZWxwb3NpdGlvbjogMX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgc3ViT2JqWycmbmJzcDsnICsgc3ViTWVudU5hbWVdLmFjdGlvbiA9ICdjbGljayc7XG4gICAgICAgICAgc3ViT2JqWycmbmJzcDsnICsgc3ViTWVudU5hbWVdLnN0eWxlID0gc3ViQ2F0U3R5bGU7XG4gICAgICAgICAgb2JqW2tleV0uaGFuZGxlci5wdXNoKHN1Yk9iaik7XG4gICAgICAgICAgaWYgKGogIT09IGdhT3B0aW9uc09ialtpXS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBvYmpba2V5XS5oYW5kbGVyLnB1c2goe1xuICAgICAgICAgICAgICAnJzoge1xuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZDVkMmQyJyxcbiAgICAgICAgICAgICAgICAgIGhlaWdodDogJzFweCcsXG4gICAgICAgICAgICAgICAgICBtYXJnaW46ICcxcHgnLFxuICAgICAgICAgICAgICAgICAgcGFkZGluZzogJzBweCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29udGV4dEFycmF5LnB1c2gob2JqKTtcbiAgICAgIGNvbnRleHRBcnJheS5wdXNoKHtcbiAgICAgICAgJyc6IHtcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2Q1ZDJkMicsXG4gICAgICAgICAgICBoZWlnaHQ6ICcxcHgnLFxuICAgICAgICAgICAgbWFyZ2luOiAnMXB4JyxcbiAgICAgICAgICAgIHBhZGRpbmc6ICcwcHgnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb250ZXh0QXJyYXkucHVzaCh7XG4gICAgICAnJm5ic3A7ICZuYnNwOyBSZXNldCc6IHtcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYuYW5hbHlzZXIoJ3Jlc2V0Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIGFjdGlvbjogJ2NsaWNrJyxcbiAgICAgICAgc3R5bGU6IHN1YkNhdFN0eWxlXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb250ZXh0TWVudS5hcHBlbmRBc0xpc3QoY29udGV4dEFycmF5KTtcblxuICAgIHRoaXMuU3ltYm9sU3RvcmUucmVnaXN0ZXIoJ0NvbnRleHRJY29uJywgZnVuY3Rpb24gKHBvc3gsIHBvc3ksIHJhZCkge1xuICAgICAgdmFyIHggPSBwb3N4LFxuICAgICAgICB5ID0gcG9zeSxcbiAgICAgICAgciA9IHJhZCAqIDIsXG4gICAgICAgIHNwYWNlID0gTWF0aC5yb3VuZChyIC8gNCksXG4gICAgICAgIGhhbGZXaWR0aCA9IE1hdGgucm91bmQociAvIDIpICogMC43LFxuICAgICAgICBzdGFydFggPSAoeCAtIGhhbGZXaWR0aCksXG4gICAgICAgIGVuZFggPSAoeCArIGhhbGZXaWR0aCksXG4gICAgICAgIHN0YXJ0WSA9ICh5ICsgc3BhY2UpLFxuICAgICAgICBlbmRZID0gKHkgLSBzcGFjZSk7XG4gICAgICByZXR1cm4gWydNJywgc3RhcnRYLCB5LCAnTCcsIGVuZFgsIHksICdNJywgc3RhcnRYLCBzdGFydFksICdMJywgZW5kWCwgc3RhcnRZLCAnTScsIHN0YXJ0WCwgZW5kWSwgJ0wnLCBlbmRYLCBlbmRZXTtcbiAgICB9KTtcblxuICAgIGdyb3VwLmFkZFN5bWJvbChjb250ZXh0TWVudSk7XG4gICAgdG9vbGJhci5hZGRDb21wb25lbnQoZ3JvdXApO1xuICAgIHJldHVybiB0b29sYmFyO1xuICB9O1xuXG4gIExlZ2VuZEV4dC5wcm90b3R5cGUuZ2V0TG9naWNhbFNwYWNlID0gZnVuY3Rpb24gKGF2YWlsYWJsZVdpZHRoLCBhdmFpbGFibGVIZWlnaHQpIHtcbiAgICBhdmFpbGFibGVXaWR0aCAvPSAyO1xuICAgIHZhciBsb2dpY2FsU3BhY2UsXG4gICAgICB3aWR0aCA9IDAsXG4gICAgICBoZWlnaHQgPSAwLFxuICAgICAgaSxcbiAgICAgIGxuO1xuXG4gICAgZm9yIChpID0gMCwgbG4gPSB0aGlzLnRvb2xiYXJzLmxlbmd0aDsgaSA8IGxuOyBpKyspIHtcbiAgICAgIGxvZ2ljYWxTcGFjZSA9IHRoaXMudG9vbGJhcnNbaV0uZ2V0TG9naWNhbFNwYWNlKGF2YWlsYWJsZVdpZHRoLCBhdmFpbGFibGVIZWlnaHQpO1xuICAgICAgd2lkdGggPSBNYXRoLm1heChsb2dpY2FsU3BhY2Uud2lkdGgsIHdpZHRoKTtcbiAgICAgIGhlaWdodCArPSBsb2dpY2FsU3BhY2UuaGVpZ2h0O1xuICAgICAgdGhpcy50b29sYmFyc1tpXS53aWR0aCA9IGxvZ2ljYWxTcGFjZS53aWR0aDtcbiAgICAgIHRoaXMudG9vbGJhcnNbaV0uaGVpZ2h0ID0gbG9naWNhbFNwYWNlLmhlaWdodDtcbiAgICB9XG4gICAgaGVpZ2h0ICs9IHRoaXMucGFkZGluZztcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHdpZHRoID4gYXZhaWxhYmxlV2lkdGggPyAwIDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCA+IGF2YWlsYWJsZUhlaWdodCA/IDAgOiBoZWlnaHRcbiAgICB9O1xuICB9O1xuXG4gIExlZ2VuZEV4dC5wcm90b3R5cGUucGxhY2VJbkNhbnZhcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5wYWRkaW5nID0gNTtcbiAgICBzZWxmLnNwYWNlTWFuYWdlckluc3RhbmNlLmFkZChbe1xuICAgICAgbmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1Rvb2xCb3hFeHQnO1xuICAgICAgfSxcbiAgICAgIHJlZjogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqWycwJ107XG4gICAgICB9LFxuICAgICAgc2VsZjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH0sXG4gICAgICBwcmlvcml0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH0sXG4gICAgICBsYXlvdXQ6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iai5pbmxpbmU7XG4gICAgICB9LFxuICAgICAgb3JpZW50YXRpb246IFt7XG4gICAgICAgIHR5cGU6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICByZXR1cm4gb2JqLmhvcml6b250YWw7XG4gICAgICAgIH0sXG4gICAgICAgIHBvc2l0aW9uOiBbe1xuICAgICAgICAgIHR5cGU6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoudG9wO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWxpZ25tZW50OiBbe1xuICAgICAgICAgICAgdHlwZTogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICByZXR1cm4gb2JqLnJpZ2h0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudENvbXBvbmVudEdyb3VwKCk7XG4gICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldExvZ2ljYWxTcGFjZShwYXJlbnQuZ2V0V2lkdGgoKSwgcGFyZW50LmdldEhlaWdodCgpKTtcbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfV1cbiAgICAgICAgfV1cbiAgICAgIH1dXG4gICAgfV0pO1xuICB9O1xuXG4gIExlZ2VuZEV4dC5wcm90b3R5cGUuc2V0RHJhd2luZ0NvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgZ3JvdXApIHtcbiAgICB2YXIgbWVzID0gdGhpcy5tZWFzdXJlbWVudDtcbiAgICBtZXMueCA9IHg7XG4gICAgbWVzLnkgPSB5O1xuICAgIG1lcy53aWR0aCA9IHdpZHRoO1xuICAgIG1lcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICB0aGlzLnBhcmVudEdyb3VwID0gZ3JvdXA7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBMZWdlbmRFeHQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgZ3JvdXApIHtcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSB0aGlzLm1lYXN1cmVtZW50LFxuICAgICAgdG9vbGJhcnMgPSB0aGlzLnRvb2xiYXJzLFxuICAgICAgbG4sXG4gICAgICBpLFxuICAgICAgdG9vbGJhcjtcbiAgICB4ID0geCA9PT0gdW5kZWZpbmVkID8gbWVhc3VyZW1lbnQueCA6IHg7XG4gICAgeSA9IHkgPT09IHVuZGVmaW5lZCA/IG1lYXN1cmVtZW50LnkgOiB5O1xuICAgIHdpZHRoID0gd2lkdGggPT09IHVuZGVmaW5lZCA/IG1lYXN1cmVtZW50LndpZHRoIDogd2lkdGg7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0ID09PSB1bmRlZmluZWQgPyBtZWFzdXJlbWVudC5oZWlnaHQgOiBoZWlnaHQ7XG4gICAgZ3JvdXAgPSBncm91cCA9PT0gdW5kZWZpbmVkID8gdGhpcy5wYXJlbnRHcm91cCA6IGdyb3VwO1xuICAgIGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxuID0gdG9vbGJhcnMubGVuZ3RoOyBpIDwgbG47IGkrKykge1xuICAgICAgICB0b29sYmFyID0gdG9vbGJhcnNbaV07XG4gICAgICAgIHRvb2xiYXIuZHJhdyh4LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgRnVzaW9uQ2hhcnRzLnJlZ2lzdGVyQ29tcG9uZW50KCdleHRlbnNpb25zJywgJ2xlZ2VuZEV4dCcsIExlZ2VuZEV4dCk7XG59XSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9leHRlbnNpb24uanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuY2xhc3MgR3Jvd3RoQW5hbHlzZXIge1xuICBjb25zdHJ1Y3RvciAoZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGEubWFwKChhKSA9PiB7XG4gICAgICByZXR1cm4gYS5tYXAoKGIpID0+IHsgcmV0dXJuIGI7IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuRm9ybXVsYWUgPSBGb3JtdWxhZTtcbiAgfVxuICBhbmFseXNlIChtb2RlKSB7XG4gICAgbGV0IGkgPSAwLFxuICAgICAgaWkgPSAwLFxuICAgICAgaiA9IDAsXG4gICAgICBqaiA9IDAsXG4gICAgICBudW0gPSAwLFxuICAgICAgY2hlY2tBcnIgPSBbXSxcbiAgICAgIGNoZWNrTnVtID0gMCxcbiAgICAgIGRhdGFBciA9IHRoaXMuZGF0YSxcbiAgICAgIG5EYXRhQXIgPSBbXSxcbiAgICAgIHRlbXBBciA9IFtdLFxuICAgICAgdGVtcCA9IDA7XG4gICAgaWYgKHR5cGVvZiBtb2RlID09PSAnc3RyaW5nJyAmJiBtb2RlLnRvTG93ZXJDYXNlKCkgPT09ICdyZXNldCcpIHtcbiAgICAgIHJldHVybiBkYXRhQXIubWFwKChhKSA9PiB7XG4gICAgICAgIHJldHVybiBhLm1hcCgoYikgPT4geyByZXR1cm4gYjsgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFpc05hTihtb2RlKSkgeyAvLyBIYW5kbGluZyBhIG51bWJlclxuICAgICAgY2hlY2tOdW0gPSArbW9kZTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gZGF0YUFyLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdGVtcEFyID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGpqID0gZGF0YUFyW2ldLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBudW0gPSBkYXRhQXJbaV1bal07XG4gICAgICAgICAgdGVtcEFyLnB1c2goMTAwICogKG51bSAtIGNoZWNrTnVtKSAvIGNoZWNrTnVtKTtcbiAgICAgICAgfVxuICAgICAgICBuRGF0YUFyLnB1c2godGVtcEFyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2RlID09PSAnc3RyaW5nJykge1xuICAgICAgbW9kZSA9IHRoaXMuRm9ybXVsYWVbbW9kZV07XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGRhdGFBci5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHRlbXBBciA9IFtdO1xuICAgICAgICBjaGVja051bSA9IG1vZGUoZGF0YUFyW2ldKTtcbiAgICAgICAgZm9yIChqID0gMCwgamogPSBkYXRhQXJbaV0ubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICAgIG51bSA9IGRhdGFBcltpXVtqXTtcbiAgICAgICAgICBpZiAoY2hlY2tOdW0gPT09IDApIHtcbiAgICAgICAgICAgIHRlbXAgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbXAgPSAxMDAgKiAobnVtIC0gY2hlY2tOdW0pIC8gY2hlY2tOdW07XG4gICAgICAgICAgfVxuICAgICAgICAgIHRlbXBBci5wdXNoKHRlbXApO1xuICAgICAgICB9XG4gICAgICAgIG5EYXRhQXIucHVzaCh0ZW1wQXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzTmFOKG1vZGUucmVscG9zaXRpb24pKSB7XG4gICAgICBtb2RlID0gbW9kZS5yZWxwb3NpdGlvbjtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gZGF0YUFyLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdGVtcEFyID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGpqID0gZGF0YUFyW2ldLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBudW0gPSBkYXRhQXJbaV1bal07XG4gICAgICAgICAgaWYgKGogKyBtb2RlID49IDAgJiYgaiArIG1vZGUgPCBqaikge1xuICAgICAgICAgICAgY2hlY2tOdW0gPSBkYXRhQXJbaV1baiArIG1vZGVdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVja051bSA9IG51bTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGVtcEFyLnB1c2goMTAwICogKG51bSAtIGNoZWNrTnVtKSAvIGNoZWNrTnVtKTtcbiAgICAgICAgfVxuICAgICAgICBuRGF0YUFyLnB1c2godGVtcEFyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc05hTihtb2RlLnBvc2l0aW9uKSkge1xuICAgICAgbW9kZSA9IG1vZGUucG9zaXRpb247XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGRhdGFBci5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHRlbXBBciA9IFtdO1xuICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGRhdGFBcltpXS5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgbnVtID0gZGF0YUFyW2ldW2pdO1xuICAgICAgICAgIGlmIChtb2RlID49IDAgJiYgbW9kZSA8IGpqKSB7XG4gICAgICAgICAgICBjaGVja051bSA9IGRhdGFBcltpXVttb2RlXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tOdW0gPSBudW07XG4gICAgICAgICAgfVxuICAgICAgICAgIHRlbXBBci5wdXNoKDEwMCAqIChudW0gLSBjaGVja051bSkgLyBjaGVja051bSk7XG4gICAgICAgIH1cbiAgICAgICAgbkRhdGFBci5wdXNoKHRlbXBBcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNOYU4obW9kZS5yZWxkYXRhc2V0cG9zaXRpb24pKSB7XG4gICAgICBtb2RlID0gbW9kZS5yZWxkYXRhc2V0cG9zaXRpb247XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGRhdGFBci5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHRlbXBBciA9IFtdO1xuICAgICAgICBpZiAoaSArIG1vZGUgPj0gMCAmJiBpICsgbW9kZSA8IGlpKSB7XG4gICAgICAgICAgY2hlY2tBcnIgPSBkYXRhQXJbaSArIG1vZGVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoZWNrQXJyID0gZGF0YUFyW2ldO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IDAsIGpqID0gZGF0YUFyW2ldLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBjaGVja051bSA9IGNoZWNrQXJyW2pdO1xuICAgICAgICAgIG51bSA9IGRhdGFBcltpXVtqXTtcbiAgICAgICAgICB0ZW1wQXIucHVzaCgxMDAgKiAobnVtIC0gY2hlY2tOdW0pIC8gbnVtKTtcbiAgICAgICAgfVxuICAgICAgICBuRGF0YUFyLnB1c2godGVtcEFyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gMCwgaWkgPSBuRGF0YUFyLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGZvciAoaiA9IDAsIGpqID0gbkRhdGFBcltpXS5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG5EYXRhQXJbaV1bal0pKSB7XG4gICAgICAgICAgbkRhdGFBcltpXVtqXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5EYXRhQXI7XG4gIH1cbn1cblxudmFyIEZvcm11bGFlID0ge1xuICBNaW5pbXVtOiAoYXJyKSA9PiB7XG4gICAgcmV0dXJuIGFyci5yZWR1Y2UoKGEsIGIpID0+IHtcbiAgICAgIHJldHVybiBhID4gYiA/IGIgOiBhO1xuICAgIH0pO1xuICB9LFxuICBNYXhpbXVtOiAoYXJyKSA9PiB7XG4gICAgcmV0dXJuIGFyci5yZWR1Y2UoKGEsIGIpID0+IHtcbiAgICAgIHJldHVybiBhIDwgYiA/IGIgOiBhO1xuICAgIH0pO1xuICB9LFxuICBNZWFuOiAoYXJyKSA9PiB7XG4gICAgcmV0dXJuIGFyci5yZWR1Y2UoKGEsIGIpID0+IHtcbiAgICAgIHJldHVybiBhICsgYjtcbiAgICB9KSAvIGFyci5sZW5ndGg7XG4gIH0sXG4gIE1lZGlhbjogKGFycikgPT4ge1xuICAgIHJldHVybiBhcnIubWFwKChhKSA9PiBhKS5zb3J0KChhLCBiKSA9PiB7IHJldHVybiBhIC0gYjsgfSlbYXJyLmxlbmd0aCAvIDJdO1xuICB9LFxuICAnU3RhbmRhcmQgRGV2aWF0aW9uJzogKHZhbHVlcykgPT4ge1xuICAgIGZ1bmN0aW9uIGF2ZXJhZ2UgKGRhdGEpIHtcbiAgICAgIHZhciBzdW0sIGF2ZztcbiAgICAgIHN1bSA9IGRhdGEucmVkdWNlKGZ1bmN0aW9uIChzdW0sIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBzdW0gKyB2YWx1ZTtcbiAgICAgIH0sIDApO1xuXG4gICAgICBhdmcgPSBzdW0gLyBkYXRhLmxlbmd0aDtcbiAgICAgIHJldHVybiBhdmc7XG4gICAgfVxuICAgIHZhciBhdmcgPSAwLFxuICAgICAgc3F1YXJlRGlmZnMgPSAwLFxuICAgICAgc3FyRGlmZiA9IDAsXG4gICAgICBhdmdTcXVhcmVEaWZmID0gMCxcbiAgICAgIHN0ZERldiA9IDAsXG4gICAgICBkaWZmID0gMDtcbiAgICBhdmcgPSBhdmVyYWdlKHZhbHVlcyk7XG4gICAgc3F1YXJlRGlmZnMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgZGlmZiA9IHZhbHVlIC0gYXZnO1xuICAgICAgc3FyRGlmZiA9IGRpZmYgKiBkaWZmO1xuICAgICAgcmV0dXJuIHNxckRpZmY7XG4gICAgfSk7XG4gICAgYXZnU3F1YXJlRGlmZiA9IGF2ZXJhZ2Uoc3F1YXJlRGlmZnMpO1xuICAgIHN0ZERldiA9IE1hdGguc3FydChhdmdTcXVhcmVEaWZmKTtcbiAgICByZXR1cm4gc3RkRGV2O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyb3d0aEFuYWx5c2VyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZ3Jvd3RoYW5hbHlzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl19
