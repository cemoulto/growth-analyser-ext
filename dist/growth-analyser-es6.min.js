(function(window, document, undefined) {
"use strict";

FusionCharts.register('extension', ['private', 'legend-ext', function () {
  function LegendExt () {
    this.toolbox = FusionCharts.getComponent('api', 'toolbox');
    this.HorizontalToolbar = this.toolbox.HorizontalToolbar;
    this.ComponentGroup = this.toolbox.ComponentGroup;
    this.SymbolStore = this.toolbox.SymbolStore;
  }
  LegendExt.prototype.constructor = LegendExt;

  LegendExt.prototype.renderChange = function () {
    var chartInstance = this.tsObject.chartInstance,
      componentStore = chartInstance.apiInstance.getComponentStore(),
      i = 0;
    for (i = 0; componentStore.getCanvasByIndex(i); ++i) {
      componentStore.getCanvasByIndex(i).getComposition().PlotManager.plot();
    }
  };

  LegendExt.prototype.analyser = function (mode) {
    var ga = this.ga || {},
      store = this.tsObject.apiInstance.getComponentStore(),
      canvas = store.getCanvasByIndex(0),
      nav = store.getNavigatorByIndex(0),
      comp = canvas.getComposition(),
      ds = ga.ds || comp.dataset,
      i,
      idMap = ga.idMap || {},
      storeAr = ga.storeAr || [],
      nStoreArr = [],
      yAxis = canvas.composition.yAxis;
    // Changing y Axis formattor
    debugger;
    if (mode === 'reset') {
      yAxis.getScaleObj().getIntervalObj().getConfig('intervals').major.formatter = function (val) {
        return val;
      };
    } else {
      yAxis.getScaleObj().getIntervalObj().getConfig('intervals').major.formatter = function (val) {
        return val + '%';
      };
    }
    // Declaration ends
    this.ga = ga;
    if (!ga.storeAr) {
      store = {};
      if (!ga.idMap) {
        ds.forEachSeries(function (a, b, c, series) {
          store[series.getId()] = series.getOriginalData();
        });
        for (i in store) {
          storeAr.push(store[i]);
          idMap[i] = storeAr.length - 1;
          // = store[i].map(function (e) { return 20 * e + (Math.random() * 1000); });
        }
        ga.idMap = idMap;
        ga.ds = ds;
        ga.storeAr = storeAr;
        ga.gAnalyser = new GrowthAnalyser(storeAr);
      }
    }
    nStoreArr = ga.gAnalyser.analyse(mode);
    ds.setDataBySeries(function (series) {
      if (nStoreArr.length) {
        series.setOriginalData(nStoreArr[idMap[series.getId()]]);
      }
    });
    comp.impl.update();
  };

  LegendExt.prototype.init = function (require) {
    var instance = this;
    require([
      'xAxis',
      'yAxis',
      'graphics',
      'chart',
      'dataset',
      'PlotManager',
      'canvasConfig',
      'MarkerManager',
      'reactiveModel',
      'globalReactiveModel',
      'spaceManagerInstance',
      'smartLabel',
      'chartInstance',
      'canvasData',
      function (
            xAxis,
            yAxis,
            graphics,
            chart,
            dataset,
            plotManager,
            canvasConfig,
            markerManager,
            reactiveModel,
            globalReactiveModel,
            spaceManagerInstance,
            smartLabel,
            chartInstance,
            canvasData) {
        instance.xAxis = xAxis;
        instance.yAxis = yAxis;
        instance.graphics = graphics;
        instance.chart = chart;
        instance.dataset = dataset;
        instance.plotManager = plotManager;
        instance.markerManager = markerManager;
        instance.canvasConfig = canvasConfig;
        instance.reactiveModel = reactiveModel;
        instance.globalReactiveModel = globalReactiveModel;
        instance.spaceManagerInstance = spaceManagerInstance;
        instance.smartLabel = smartLabel;
        instance.chartInstance = chartInstance;
        instance.canvasData = canvasData;
      }
    ]);
    this.spaceManagerInstance = instance.spaceManagerInstance;
    this.globalReactiveModel = instance.globalReactiveModel;
    this.tsObject = instance.chartInstance;
    this.startDt = instance.globalReactiveModel.model['x-axis-visible-range-start'];
    this.endDt = instance.globalReactiveModel.model['x-axis-visible-range-end'];
    this.startDataset = instance.globalReactiveModel.model['x-axis-absolute-range-start'];
    this.endDataset = instance.globalReactiveModel.model['x-axis-absolute-range-end'];
    this.toolbars = [];
    this.measurement = {};
    this.toolbars.push(this.createToolbar());
    return this;
  };

  LegendExt.prototype.createToolbar = function () {
    var toolbar,
      group,
      self = this,
      contextMenu,
      contextArray = [],
      gaOptionsObj = {},
      popup,
      paper = this.graphics.paper,
      chartContainer = this.graphics.container,
      subCatStyle = {
        'font-size': '12px',
        'color': '#696969'
      };

    toolbar = new this.HorizontalToolbar({
      paper: this.graphics.paper,
      chart: this.chart,
      smartLabel: this.smartLabel,
      chartContainer: this.graphics.container
    });

    toolbar.setConfig({
      fill: '#fff',
      borderThickness: 0
    });

    group = new this.toolbox.ComponentGroup({
      paper: this.graphics.paper,
      chart: this.chart,
      smartLabel: this.smartLabel,
      chartContainer: this.graphics.container
    });

    group.setConfig({
      fill: '#fff',
      borderThickness: 0
    });

    gaOptionsObj = {
      'Fixed-Number': 'dialogBox',
      'Functions': ['Minimum', 'Maximum', 'Mean', 'Median', 'Standard Deviation'],
      'Position': 'dialogBox',
      'Dataset': ['Previous Dataset', 'Next Dataset'],
      'Relative-Position': ['Next', 'Previous']
    };

    contextMenu = new this.toolbox.SymbolWithContext('ContextIcon', {
      paper: this.graphics.paper,
      chart: this.chart,
      smartLabel: this.smartLabel,
      chartContainer: this.graphics.container
    }, {
      width: 19,
      height: 19,
      position: 'right',
      stroke: '#ced5d4',
      symbolStroke: '#696969'
    });

    contextArray.push({
      'Growth Analyser': {
        style: {
          'color': '#696969',
          'font-family': 'MyriadPro',
          'font-weight': 'bold'
        }
      }
    });
    popup = function (callback) {
      var box,
        header,
        style = {
          fontSize: 10 + 'px',
          lineHeight: 15 + 'px',
          fontFamily: 'Lucida Grande',
          stroke: '#676767',
          'stroke-width': '2'
        },
        headerWidth = 180,
        headerText,
        cross,
        inputField,
        applyButton,
        x = 500,
        y = 100;

      box = paper.html('div', {
        fill: '#f7f7f7',
        x: x - 200,
        y: y + 100,
        width: 180,
        height: 80
      }, style, chartContainer);

      header = paper.html('div', {
        fill: '#e8e8e8',
        width: headerWidth,
        height: 20
      }, style, box);

      headerText = paper.html('div', {
        fill: 'transparent',
        width: headerWidth * 0.6,
        height: 20,
        x: 10,
        y: 2
      }, style, header);

      headerText.attr({
        text: 'Provide Specific Value'
      });

      cross = paper.html('div', {
        fill: 'transparent',
        width: 10,
        height: 10,
        position: 'relative',
        float: 'right',
        text: 'X',
        cursor: 'pointer'
      }, style, header);

      cross.on('click', function () {
        box.hide();
      });

      inputField = paper.html('input', {
        width: 100,
        height: 20,
        x: 10,
        y: 30
      }, style, box);

      applyButton = paper.html('div', {
        width: 50,
        height: 20,
        x: 120,
        y: 30,
        fill: '#555555'
      }, {
        fontSize: 10 + 'px',
        lineHeight: 15 + 'px',
        fontFamily: 'Lucida Grande',
        fill: '#eaeaea',
        color: '#eaeaea',
        stroke: '#eaeaea',
        cursor: 'pointer'
      }, box);

      applyButton.on('click', function () {
        box.hide();
        callback(inputField.val());
      });
      applyButton.attr({
        text: 'Apply'
      });
      inputField.element.focus();
      function inputFieldNumberHandler () {
        inputField.element.value = inputField.element.value.replace(/[^\d.-]/g, '');
      }
      inputField.element.addEventListener('keyup', inputFieldNumberHandler);
      cross.element.style['position'] = 'relative';
      cross.element.style['backgroundColor'] = '#d2d2d2';
      cross.element.style['border'] = '2px solid #cbcbcb';
      cross.element.style['padding'] = '0px 0px 3.5px 2px';
      cross.element.style['color'] = '#8c8c8c';
      cross.element.style['margin'] = '1px 2px';
      cross.element.style['float'] = 'right';
      inputField.element.style['marginTop'] = '8px';
      inputField.element.style['border'] = '2px solid #dadbda';
      applyButton.element.style['marginTop'] = '8px';
      box.element.style['border'] = '1px solid #d4d2d3';
      header.element.style['border'] = '1px solid #d4d2d3';
      header.element.style['width'] = '179px';
      headerText.element.style['fontSize'] = '11.5px';
      headerText.element.style['marginTop'] = '0.5px';
      headerText.element.style['color'] = '#676767';
      header.element.style['fontFamily'] = 'MyriadPro';
      applyButton.element.style['textAlign'] = 'center';
      applyButton.element.style['fontSize'] = '11px';
      applyButton.element.style['paddingTop'] = '3px';
      applyButton.element.style['borderRadius'] = '3px';
      applyButton.element.style['color'] = '#e4e4e4';
    };

    for (let i in gaOptionsObj) {
      let key,
        obj = {},
        subObj = {};
      if (gaOptionsObj[i] === 'dialogBox') {
        key = '&nbsp; &nbsp; ' + i;
        obj[key] = {};
        obj[key] = {
          style: subCatStyle,
          handler: function () {
            // let popupVal = popup(function (str) {
            //   self.analyser(parseInt(str));
            // });
            if (i === 'Fixed-Number') {
              // self.analyser(parseInt(window.prompt('Enter value')));
              let popupVal = popup(function (str) {
                self.analyser(parseInt(str));
              });
            } else if (i === 'Position') {
              let popupVal = popup(function (str) {
                self.analyser({position: str});
              });
            }
          },
          action: 'click'
        };
      } else {
        key = '&#9666&nbsp; ' + i;
        obj[key] = {};
        obj[key].action = 'click';
        obj[key].style = subCatStyle;
        obj[key].handler = [];
        for (let j = 0; j < gaOptionsObj[i].length; j++) {
          let subMenuName = gaOptionsObj[i][j];
          subObj = {};
          subObj['&nbsp;' + subMenuName] = {};
          subObj['&nbsp;' + subMenuName].handler = function () {
            // ['Minimum', 'Maximum', 'Mean', 'Median', 'Standard Deviation']
            // ['Previous Dataset', 'Next Dataset']
            // ['Next', 'Previous']
            if (subMenuName === 'Minimum' ||
              subMenuName === 'Maximum' || subMenuName === 'Mean' ||
              subMenuName === 'Median' || subMenuName === 'Standard Deviation') {
              self.analyser(subMenuName);
            } else if (subMenuName === 'Previous Dataset') {
              self.analyser({reldatasetposition: -1});
            } else if (subMenuName === 'Next Dataset') {
              self.analyser({reldatasetposition: 1});
            } else if (subMenuName === 'Next') {
              self.analyser({relposition: -1});
            } else if (subMenuName === 'Previous') {
              self.analyser({relposition: 1});
            }
          };
          subObj['&nbsp;' + subMenuName].action = 'click';
          subObj['&nbsp;' + subMenuName].style = subCatStyle;
          obj[key].handler.push(subObj);
          if (j !== gaOptionsObj[i].length - 1) {
            obj[key].handler.push({
              '': {
                style: {
                  backgroundColor: '#d5d2d2',
                  height: '1px',
                  margin: '1px',
                  padding: '0px'
                }
              }
            });
          }
        }
      }
      contextArray.push(obj);
      contextArray.push({
        '': {
          style: {
            backgroundColor: '#d5d2d2',
            height: '1px',
            margin: '1px',
            padding: '0px'
          }
        }
      });
    }

    contextArray.push({
      '&nbsp; &nbsp; Reset': {
        handler: function () {
          self.analyser('reset');
        },
        action: 'click',
        style: subCatStyle
      }
    });

    contextMenu.appendAsList(contextArray);

    this.SymbolStore.register('ContextIcon', function (posx, posy, rad) {
      var x = posx,
        y = posy,
        r = rad * 2,
        space = Math.round(r / 4),
        halfWidth = Math.round(r / 2) * 0.7,
        startX = (x - halfWidth),
        endX = (x + halfWidth),
        startY = (y + space),
        endY = (y - space);
      return ['M', startX, y, 'L', endX, y, 'M', startX, startY, 'L', endX, startY, 'M', startX, endY, 'L', endX, endY];
    });

    group.addSymbol(contextMenu);
    toolbar.addComponent(group);
    return toolbar;
  };

  LegendExt.prototype.getLogicalSpace = function (availableWidth, availableHeight) {
    availableWidth /= 2;
    var logicalSpace,
      width = 0,
      height = 0,
      i,
      ln;

    for (i = 0, ln = this.toolbars.length; i < ln; i++) {
      logicalSpace = this.toolbars[i].getLogicalSpace(availableWidth, availableHeight);
      width = Math.max(logicalSpace.width, width);
      height += logicalSpace.height;
      this.toolbars[i].width = logicalSpace.width;
      this.toolbars[i].height = logicalSpace.height;
    }
    height += this.padding;
    return {
      width: width > availableWidth ? 0 : width,
      height: height > availableHeight ? 0 : height
    };
  };

  LegendExt.prototype.placeInCanvas = function () {
    var self = this;
    self.padding = 5;
    self.spaceManagerInstance.add([{
      name: function () {
        return 'ToolBoxExt';
      },
      ref: function (obj) {
        return obj['0'];
      },
      self: function () {
        return self;
      },
      priority: function () {
        return 2;
      },
      layout: function (obj) {
        return obj.inline;
      },
      orientation: [{
        type: function (obj) {
          return obj.horizontal;
        },
        position: [{
          type: function (obj) {
            return obj.top;
          },
          alignment: [{
            type: function (obj) {
              return obj.right;
            },
            dimensions: [function () {
              var parent = this.getParentComponentGroup();
              return self.getLogicalSpace(parent.getWidth(), parent.getHeight());
            }]
          }]
        }]
      }]
    }]);
  };

  LegendExt.prototype.setDrawingConfiguration = function (x, y, width, height, group) {
    var mes = this.measurement;
    mes.x = x;
    mes.y = y;
    mes.width = width;
    mes.height = height;

    this.parentGroup = group;

    return this;
  };

  LegendExt.prototype.draw = function (x, y, width, height, group) {
    var measurement = this.measurement,
      toolbars = this.toolbars,
      ln,
      i,
      toolbar;
    x = x === undefined ? measurement.x : x;
    y = y === undefined ? measurement.y : y;
    width = width === undefined ? measurement.width : width;
    height = height === undefined ? measurement.height : height;
    group = group === undefined ? this.parentGroup : group;
    if (width && height) {
      for (i = 0, ln = toolbars.length; i < ln; i++) {
        toolbar = toolbars[i];
        toolbar.draw(x, y);
      }
    }
  };

  FusionCharts.registerComponent('extensions', 'legendExt', LegendExt);
}]);

'use strict';
class GrowthAnalyser {
  constructor (data) {
    this.data = data.map((a) => {
      return a.map((b) => { return b; });
    });
    this.Formulae = Formulae;
  }
  analyse (mode) {
    let i = 0,
      ii = 0,
      j = 0,
      jj = 0,
      num = 0,
      checkArr = [],
      checkNum = 0,
      dataAr = this.data,
      nDataAr = [],
      tempAr = [],
      temp = 0;
    if (typeof mode === 'string' && mode.toLowerCase() === 'reset') {
      return dataAr.map((a) => {
        return a.map((b) => { return b; });
      });
    } else if (!isNaN(mode)) { // Handling a number
      checkNum = +mode;
      for (i = 0, ii = dataAr.length; i < ii; ++i) {
        tempAr = [];
        for (j = 0, jj = dataAr[i].length; j < jj; ++j) {
          num = dataAr[i][j];
          tempAr.push(100 * (num - checkNum) / checkNum);
        }
        nDataAr.push(tempAr);
      }
    } else if (typeof mode === 'string') {
      mode = this.Formulae[mode];
      for (i = 0, ii = dataAr.length; i < ii; ++i) {
        tempAr = [];
        checkNum = mode(dataAr[i]);
        for (j = 0, jj = dataAr[i].length; j < jj; ++j) {
          num = dataAr[i][j];
          if (checkNum === 0) {
            temp = undefined;
          } else {
            temp = 100 * (num - checkNum) / checkNum;
          }
          tempAr.push(temp);
        }
        nDataAr.push(tempAr);
      }
    } else if (!isNaN(mode.relposition)) {
      mode = mode.relposition;
      for (i = 0, ii = dataAr.length; i < ii; ++i) {
        tempAr = [];
        for (j = 0, jj = dataAr[i].length; j < jj; ++j) {
          num = dataAr[i][j];
          if (j + mode >= 0 && j + mode < jj) {
            checkNum = dataAr[i][j + mode];
          } else {
            checkNum = num;
          }
          tempAr.push(100 * (num - checkNum) / checkNum);
        }
        nDataAr.push(tempAr);
      }
    } else if (!isNaN(mode.position)) {
      mode = mode.position;
      for (i = 0, ii = dataAr.length; i < ii; ++i) {
        tempAr = [];
        for (j = 0, jj = dataAr[i].length; j < jj; ++j) {
          num = dataAr[i][j];
          if (mode >= 0 && mode < jj) {
            checkNum = dataAr[i][mode];
          } else {
            checkNum = num;
          }
          tempAr.push(100 * (num - checkNum) / checkNum);
        }
        nDataAr.push(tempAr);
      }
    } else if (!isNaN(mode.reldatasetposition)) {
      mode = mode.reldatasetposition;
      for (i = 0, ii = dataAr.length; i < ii; ++i) {
        tempAr = [];
        if (i + mode >= 0 && i + mode < ii) {
          checkArr = dataAr[i + mode];
        } else {
          checkArr = dataAr[i];
        }
        for (j = 0, jj = dataAr[i].length; j < jj; ++j) {
          checkNum = checkArr[j];
          num = dataAr[i][j];
          tempAr.push(100 * (num - checkNum) / num);
        }
        nDataAr.push(tempAr);
      }
    }
    for (i = 0, ii = nDataAr.length; i < ii; ++i) {
      for (j = 0, jj = nDataAr[i].length; j < jj; ++j) {
        if (!Number.isFinite(nDataAr[i][j])) {
          nDataAr[i][j] = null;
        }
      }
    }
    return nDataAr;
  }
}

var Formulae = {
  Minimum: (arr) => {
    return arr.reduce((a, b) => {
      return a > b ? b : a;
    });
  },
  Maximum: (arr) => {
    return arr.reduce((a, b) => {
      return a < b ? b : a;
    });
  },
  Mean: (arr) => {
    return arr.reduce((a, b) => {
      return a + b;
    }) / arr.length;
  },
  Median: (arr) => {
    return arr.map((a) => a).sort((a, b) => { return a - b; })[arr.length / 2];
  },
  'Standard Deviation': (values) => {
    function average (data) {
      var sum, avg;
      sum = data.reduce(function (sum, value) {
        return sum + value;
      }, 0);

      avg = sum / data.length;
      return avg;
    }
    var avg = 0,
      squareDiffs = 0,
      sqrDiff = 0,
      avgSquareDiff = 0,
      stdDev = 0,
      diff = 0;
    avg = average(values);
    squareDiffs = values.map(function (value) {
      diff = value - avg;
      sqrDiff = diff * diff;
      return sqrDiff;
    });
    avgSquareDiff = average(squareDiffs);
    stdDev = Math.sqrt(avgSquareDiff);
    return stdDev;
  }
};
}(this, document));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJncm93dGgtYW5hbHlzZXItZXM2Lm1pbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24od2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuRnVzaW9uQ2hhcnRzLnJlZ2lzdGVyKCdleHRlbnNpb24nLCBbJ3ByaXZhdGUnLCAnbGVnZW5kLWV4dCcsIGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGVnZW5kRXh0ICgpIHtcbiAgICB0aGlzLnRvb2xib3ggPSBGdXNpb25DaGFydHMuZ2V0Q29tcG9uZW50KCdhcGknLCAndG9vbGJveCcpO1xuICAgIHRoaXMuSG9yaXpvbnRhbFRvb2xiYXIgPSB0aGlzLnRvb2xib3guSG9yaXpvbnRhbFRvb2xiYXI7XG4gICAgdGhpcy5Db21wb25lbnRHcm91cCA9IHRoaXMudG9vbGJveC5Db21wb25lbnRHcm91cDtcbiAgICB0aGlzLlN5bWJvbFN0b3JlID0gdGhpcy50b29sYm94LlN5bWJvbFN0b3JlO1xuICB9XG4gIExlZ2VuZEV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMZWdlbmRFeHQ7XG5cbiAgTGVnZW5kRXh0LnByb3RvdHlwZS5yZW5kZXJDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNoYXJ0SW5zdGFuY2UgPSB0aGlzLnRzT2JqZWN0LmNoYXJ0SW5zdGFuY2UsXG4gICAgICBjb21wb25lbnRTdG9yZSA9IGNoYXJ0SW5zdGFuY2UuYXBpSW5zdGFuY2UuZ2V0Q29tcG9uZW50U3RvcmUoKSxcbiAgICAgIGkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGNvbXBvbmVudFN0b3JlLmdldENhbnZhc0J5SW5kZXgoaSk7ICsraSkge1xuICAgICAgY29tcG9uZW50U3RvcmUuZ2V0Q2FudmFzQnlJbmRleChpKS5nZXRDb21wb3NpdGlvbigpLlBsb3RNYW5hZ2VyLnBsb3QoKTtcbiAgICB9XG4gIH07XG5cbiAgTGVnZW5kRXh0LnByb3RvdHlwZS5hbmFseXNlciA9IGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgdmFyIGdhID0gdGhpcy5nYSB8fCB7fSxcbiAgICAgIHN0b3JlID0gdGhpcy50c09iamVjdC5hcGlJbnN0YW5jZS5nZXRDb21wb25lbnRTdG9yZSgpLFxuICAgICAgY2FudmFzID0gc3RvcmUuZ2V0Q2FudmFzQnlJbmRleCgwKSxcbiAgICAgIG5hdiA9IHN0b3JlLmdldE5hdmlnYXRvckJ5SW5kZXgoMCksXG4gICAgICBjb21wID0gY2FudmFzLmdldENvbXBvc2l0aW9uKCksXG4gICAgICBkcyA9IGdhLmRzIHx8IGNvbXAuZGF0YXNldCxcbiAgICAgIGksXG4gICAgICBpZE1hcCA9IGdhLmlkTWFwIHx8IHt9LFxuICAgICAgc3RvcmVBciA9IGdhLnN0b3JlQXIgfHwgW10sXG4gICAgICBuU3RvcmVBcnIgPSBbXSxcbiAgICAgIHlBeGlzID0gY2FudmFzLmNvbXBvc2l0aW9uLnlBeGlzO1xuICAgIC8vIENoYW5naW5nIHkgQXhpcyBmb3JtYXR0b3JcbiAgICBkZWJ1Z2dlcjtcbiAgICBpZiAobW9kZSA9PT0gJ3Jlc2V0Jykge1xuICAgICAgeUF4aXMuZ2V0U2NhbGVPYmooKS5nZXRJbnRlcnZhbE9iaigpLmdldENvbmZpZygnaW50ZXJ2YWxzJykubWFqb3IuZm9ybWF0dGVyID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgeUF4aXMuZ2V0U2NhbGVPYmooKS5nZXRJbnRlcnZhbE9iaigpLmdldENvbmZpZygnaW50ZXJ2YWxzJykubWFqb3IuZm9ybWF0dGVyID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsICsgJyUnO1xuICAgICAgfTtcbiAgICB9XG4gICAgLy8gRGVjbGFyYXRpb24gZW5kc1xuICAgIHRoaXMuZ2EgPSBnYTtcbiAgICBpZiAoIWdhLnN0b3JlQXIpIHtcbiAgICAgIHN0b3JlID0ge307XG4gICAgICBpZiAoIWdhLmlkTWFwKSB7XG4gICAgICAgIGRzLmZvckVhY2hTZXJpZXMoZnVuY3Rpb24gKGEsIGIsIGMsIHNlcmllcykge1xuICAgICAgICAgIHN0b3JlW3Nlcmllcy5nZXRJZCgpXSA9IHNlcmllcy5nZXRPcmlnaW5hbERhdGEoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoaSBpbiBzdG9yZSkge1xuICAgICAgICAgIHN0b3JlQXIucHVzaChzdG9yZVtpXSk7XG4gICAgICAgICAgaWRNYXBbaV0gPSBzdG9yZUFyLmxlbmd0aCAtIDE7XG4gICAgICAgICAgLy8gPSBzdG9yZVtpXS5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIDIwICogZSArIChNYXRoLnJhbmRvbSgpICogMTAwMCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGdhLmlkTWFwID0gaWRNYXA7XG4gICAgICAgIGdhLmRzID0gZHM7XG4gICAgICAgIGdhLnN0b3JlQXIgPSBzdG9yZUFyO1xuICAgICAgICBnYS5nQW5hbHlzZXIgPSBuZXcgR3Jvd3RoQW5hbHlzZXIoc3RvcmVBcik7XG4gICAgICB9XG4gICAgfVxuICAgIG5TdG9yZUFyciA9IGdhLmdBbmFseXNlci5hbmFseXNlKG1vZGUpO1xuICAgIGRzLnNldERhdGFCeVNlcmllcyhmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgICBpZiAoblN0b3JlQXJyLmxlbmd0aCkge1xuICAgICAgICBzZXJpZXMuc2V0T3JpZ2luYWxEYXRhKG5TdG9yZUFycltpZE1hcFtzZXJpZXMuZ2V0SWQoKV1dKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb21wLmltcGwudXBkYXRlKCk7XG4gIH07XG5cbiAgTGVnZW5kRXh0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB0aGlzO1xuICAgIHJlcXVpcmUoW1xuICAgICAgJ3hBeGlzJyxcbiAgICAgICd5QXhpcycsXG4gICAgICAnZ3JhcGhpY3MnLFxuICAgICAgJ2NoYXJ0JyxcbiAgICAgICdkYXRhc2V0JyxcbiAgICAgICdQbG90TWFuYWdlcicsXG4gICAgICAnY2FudmFzQ29uZmlnJyxcbiAgICAgICdNYXJrZXJNYW5hZ2VyJyxcbiAgICAgICdyZWFjdGl2ZU1vZGVsJyxcbiAgICAgICdnbG9iYWxSZWFjdGl2ZU1vZGVsJyxcbiAgICAgICdzcGFjZU1hbmFnZXJJbnN0YW5jZScsXG4gICAgICAnc21hcnRMYWJlbCcsXG4gICAgICAnY2hhcnRJbnN0YW5jZScsXG4gICAgICAnY2FudmFzRGF0YScsXG4gICAgICBmdW5jdGlvbiAoXG4gICAgICAgICAgICB4QXhpcyxcbiAgICAgICAgICAgIHlBeGlzLFxuICAgICAgICAgICAgZ3JhcGhpY3MsXG4gICAgICAgICAgICBjaGFydCxcbiAgICAgICAgICAgIGRhdGFzZXQsXG4gICAgICAgICAgICBwbG90TWFuYWdlcixcbiAgICAgICAgICAgIGNhbnZhc0NvbmZpZyxcbiAgICAgICAgICAgIG1hcmtlck1hbmFnZXIsXG4gICAgICAgICAgICByZWFjdGl2ZU1vZGVsLFxuICAgICAgICAgICAgZ2xvYmFsUmVhY3RpdmVNb2RlbCxcbiAgICAgICAgICAgIHNwYWNlTWFuYWdlckluc3RhbmNlLFxuICAgICAgICAgICAgc21hcnRMYWJlbCxcbiAgICAgICAgICAgIGNoYXJ0SW5zdGFuY2UsXG4gICAgICAgICAgICBjYW52YXNEYXRhKSB7XG4gICAgICAgIGluc3RhbmNlLnhBeGlzID0geEF4aXM7XG4gICAgICAgIGluc3RhbmNlLnlBeGlzID0geUF4aXM7XG4gICAgICAgIGluc3RhbmNlLmdyYXBoaWNzID0gZ3JhcGhpY3M7XG4gICAgICAgIGluc3RhbmNlLmNoYXJ0ID0gY2hhcnQ7XG4gICAgICAgIGluc3RhbmNlLmRhdGFzZXQgPSBkYXRhc2V0O1xuICAgICAgICBpbnN0YW5jZS5wbG90TWFuYWdlciA9IHBsb3RNYW5hZ2VyO1xuICAgICAgICBpbnN0YW5jZS5tYXJrZXJNYW5hZ2VyID0gbWFya2VyTWFuYWdlcjtcbiAgICAgICAgaW5zdGFuY2UuY2FudmFzQ29uZmlnID0gY2FudmFzQ29uZmlnO1xuICAgICAgICBpbnN0YW5jZS5yZWFjdGl2ZU1vZGVsID0gcmVhY3RpdmVNb2RlbDtcbiAgICAgICAgaW5zdGFuY2UuZ2xvYmFsUmVhY3RpdmVNb2RlbCA9IGdsb2JhbFJlYWN0aXZlTW9kZWw7XG4gICAgICAgIGluc3RhbmNlLnNwYWNlTWFuYWdlckluc3RhbmNlID0gc3BhY2VNYW5hZ2VySW5zdGFuY2U7XG4gICAgICAgIGluc3RhbmNlLnNtYXJ0TGFiZWwgPSBzbWFydExhYmVsO1xuICAgICAgICBpbnN0YW5jZS5jaGFydEluc3RhbmNlID0gY2hhcnRJbnN0YW5jZTtcbiAgICAgICAgaW5zdGFuY2UuY2FudmFzRGF0YSA9IGNhbnZhc0RhdGE7XG4gICAgICB9XG4gICAgXSk7XG4gICAgdGhpcy5zcGFjZU1hbmFnZXJJbnN0YW5jZSA9IGluc3RhbmNlLnNwYWNlTWFuYWdlckluc3RhbmNlO1xuICAgIHRoaXMuZ2xvYmFsUmVhY3RpdmVNb2RlbCA9IGluc3RhbmNlLmdsb2JhbFJlYWN0aXZlTW9kZWw7XG4gICAgdGhpcy50c09iamVjdCA9IGluc3RhbmNlLmNoYXJ0SW5zdGFuY2U7XG4gICAgdGhpcy5zdGFydER0ID0gaW5zdGFuY2UuZ2xvYmFsUmVhY3RpdmVNb2RlbC5tb2RlbFsneC1heGlzLXZpc2libGUtcmFuZ2Utc3RhcnQnXTtcbiAgICB0aGlzLmVuZER0ID0gaW5zdGFuY2UuZ2xvYmFsUmVhY3RpdmVNb2RlbC5tb2RlbFsneC1heGlzLXZpc2libGUtcmFuZ2UtZW5kJ107XG4gICAgdGhpcy5zdGFydERhdGFzZXQgPSBpbnN0YW5jZS5nbG9iYWxSZWFjdGl2ZU1vZGVsLm1vZGVsWyd4LWF4aXMtYWJzb2x1dGUtcmFuZ2Utc3RhcnQnXTtcbiAgICB0aGlzLmVuZERhdGFzZXQgPSBpbnN0YW5jZS5nbG9iYWxSZWFjdGl2ZU1vZGVsLm1vZGVsWyd4LWF4aXMtYWJzb2x1dGUtcmFuZ2UtZW5kJ107XG4gICAgdGhpcy50b29sYmFycyA9IFtdO1xuICAgIHRoaXMubWVhc3VyZW1lbnQgPSB7fTtcbiAgICB0aGlzLnRvb2xiYXJzLnB1c2godGhpcy5jcmVhdGVUb29sYmFyKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIExlZ2VuZEV4dC5wcm90b3R5cGUuY3JlYXRlVG9vbGJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdG9vbGJhcixcbiAgICAgIGdyb3VwLFxuICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICBjb250ZXh0TWVudSxcbiAgICAgIGNvbnRleHRBcnJheSA9IFtdLFxuICAgICAgZ2FPcHRpb25zT2JqID0ge30sXG4gICAgICBwb3B1cCxcbiAgICAgIHBhcGVyID0gdGhpcy5ncmFwaGljcy5wYXBlcixcbiAgICAgIGNoYXJ0Q29udGFpbmVyID0gdGhpcy5ncmFwaGljcy5jb250YWluZXIsXG4gICAgICBzdWJDYXRTdHlsZSA9IHtcbiAgICAgICAgJ2ZvbnQtc2l6ZSc6ICcxMnB4JyxcbiAgICAgICAgJ2NvbG9yJzogJyM2OTY5NjknXG4gICAgICB9O1xuXG4gICAgdG9vbGJhciA9IG5ldyB0aGlzLkhvcml6b250YWxUb29sYmFyKHtcbiAgICAgIHBhcGVyOiB0aGlzLmdyYXBoaWNzLnBhcGVyLFxuICAgICAgY2hhcnQ6IHRoaXMuY2hhcnQsXG4gICAgICBzbWFydExhYmVsOiB0aGlzLnNtYXJ0TGFiZWwsXG4gICAgICBjaGFydENvbnRhaW5lcjogdGhpcy5ncmFwaGljcy5jb250YWluZXJcbiAgICB9KTtcblxuICAgIHRvb2xiYXIuc2V0Q29uZmlnKHtcbiAgICAgIGZpbGw6ICcjZmZmJyxcbiAgICAgIGJvcmRlclRoaWNrbmVzczogMFxuICAgIH0pO1xuXG4gICAgZ3JvdXAgPSBuZXcgdGhpcy50b29sYm94LkNvbXBvbmVudEdyb3VwKHtcbiAgICAgIHBhcGVyOiB0aGlzLmdyYXBoaWNzLnBhcGVyLFxuICAgICAgY2hhcnQ6IHRoaXMuY2hhcnQsXG4gICAgICBzbWFydExhYmVsOiB0aGlzLnNtYXJ0TGFiZWwsXG4gICAgICBjaGFydENvbnRhaW5lcjogdGhpcy5ncmFwaGljcy5jb250YWluZXJcbiAgICB9KTtcblxuICAgIGdyb3VwLnNldENvbmZpZyh7XG4gICAgICBmaWxsOiAnI2ZmZicsXG4gICAgICBib3JkZXJUaGlja25lc3M6IDBcbiAgICB9KTtcblxuICAgIGdhT3B0aW9uc09iaiA9IHtcbiAgICAgICdGaXhlZC1OdW1iZXInOiAnZGlhbG9nQm94JyxcbiAgICAgICdGdW5jdGlvbnMnOiBbJ01pbmltdW0nLCAnTWF4aW11bScsICdNZWFuJywgJ01lZGlhbicsICdTdGFuZGFyZCBEZXZpYXRpb24nXSxcbiAgICAgICdQb3NpdGlvbic6ICdkaWFsb2dCb3gnLFxuICAgICAgJ0RhdGFzZXQnOiBbJ1ByZXZpb3VzIERhdGFzZXQnLCAnTmV4dCBEYXRhc2V0J10sXG4gICAgICAnUmVsYXRpdmUtUG9zaXRpb24nOiBbJ05leHQnLCAnUHJldmlvdXMnXVxuICAgIH07XG5cbiAgICBjb250ZXh0TWVudSA9IG5ldyB0aGlzLnRvb2xib3guU3ltYm9sV2l0aENvbnRleHQoJ0NvbnRleHRJY29uJywge1xuICAgICAgcGFwZXI6IHRoaXMuZ3JhcGhpY3MucGFwZXIsXG4gICAgICBjaGFydDogdGhpcy5jaGFydCxcbiAgICAgIHNtYXJ0TGFiZWw6IHRoaXMuc21hcnRMYWJlbCxcbiAgICAgIGNoYXJ0Q29udGFpbmVyOiB0aGlzLmdyYXBoaWNzLmNvbnRhaW5lclxuICAgIH0sIHtcbiAgICAgIHdpZHRoOiAxOSxcbiAgICAgIGhlaWdodDogMTksXG4gICAgICBwb3NpdGlvbjogJ3JpZ2h0JyxcbiAgICAgIHN0cm9rZTogJyNjZWQ1ZDQnLFxuICAgICAgc3ltYm9sU3Ryb2tlOiAnIzY5Njk2OSdcbiAgICB9KTtcblxuICAgIGNvbnRleHRBcnJheS5wdXNoKHtcbiAgICAgICdHcm93dGggQW5hbHlzZXInOiB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgJ2NvbG9yJzogJyM2OTY5NjknLFxuICAgICAgICAgICdmb250LWZhbWlseSc6ICdNeXJpYWRQcm8nLFxuICAgICAgICAgICdmb250LXdlaWdodCc6ICdib2xkJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcG9wdXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBib3gsXG4gICAgICAgIGhlYWRlcixcbiAgICAgICAgc3R5bGUgPSB7XG4gICAgICAgICAgZm9udFNpemU6IDEwICsgJ3B4JyxcbiAgICAgICAgICBsaW5lSGVpZ2h0OiAxNSArICdweCcsXG4gICAgICAgICAgZm9udEZhbWlseTogJ0x1Y2lkYSBHcmFuZGUnLFxuICAgICAgICAgIHN0cm9rZTogJyM2NzY3NjcnLFxuICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAnMidcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZGVyV2lkdGggPSAxODAsXG4gICAgICAgIGhlYWRlclRleHQsXG4gICAgICAgIGNyb3NzLFxuICAgICAgICBpbnB1dEZpZWxkLFxuICAgICAgICBhcHBseUJ1dHRvbixcbiAgICAgICAgeCA9IDUwMCxcbiAgICAgICAgeSA9IDEwMDtcblxuICAgICAgYm94ID0gcGFwZXIuaHRtbCgnZGl2Jywge1xuICAgICAgICBmaWxsOiAnI2Y3ZjdmNycsXG4gICAgICAgIHg6IHggLSAyMDAsXG4gICAgICAgIHk6IHkgKyAxMDAsXG4gICAgICAgIHdpZHRoOiAxODAsXG4gICAgICAgIGhlaWdodDogODBcbiAgICAgIH0sIHN0eWxlLCBjaGFydENvbnRhaW5lcik7XG5cbiAgICAgIGhlYWRlciA9IHBhcGVyLmh0bWwoJ2RpdicsIHtcbiAgICAgICAgZmlsbDogJyNlOGU4ZTgnLFxuICAgICAgICB3aWR0aDogaGVhZGVyV2lkdGgsXG4gICAgICAgIGhlaWdodDogMjBcbiAgICAgIH0sIHN0eWxlLCBib3gpO1xuXG4gICAgICBoZWFkZXJUZXh0ID0gcGFwZXIuaHRtbCgnZGl2Jywge1xuICAgICAgICBmaWxsOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICB3aWR0aDogaGVhZGVyV2lkdGggKiAwLjYsXG4gICAgICAgIGhlaWdodDogMjAsXG4gICAgICAgIHg6IDEwLFxuICAgICAgICB5OiAyXG4gICAgICB9LCBzdHlsZSwgaGVhZGVyKTtcblxuICAgICAgaGVhZGVyVGV4dC5hdHRyKHtcbiAgICAgICAgdGV4dDogJ1Byb3ZpZGUgU3BlY2lmaWMgVmFsdWUnXG4gICAgICB9KTtcblxuICAgICAgY3Jvc3MgPSBwYXBlci5odG1sKCdkaXYnLCB7XG4gICAgICAgIGZpbGw6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgIHdpZHRoOiAxMCxcbiAgICAgICAgaGVpZ2h0OiAxMCxcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgIGZsb2F0OiAncmlnaHQnLFxuICAgICAgICB0ZXh0OiAnWCcsXG4gICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICB9LCBzdHlsZSwgaGVhZGVyKTtcblxuICAgICAgY3Jvc3Mub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBib3guaGlkZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGlucHV0RmllbGQgPSBwYXBlci5odG1sKCdpbnB1dCcsIHtcbiAgICAgICAgd2lkdGg6IDEwMCxcbiAgICAgICAgaGVpZ2h0OiAyMCxcbiAgICAgICAgeDogMTAsXG4gICAgICAgIHk6IDMwXG4gICAgICB9LCBzdHlsZSwgYm94KTtcblxuICAgICAgYXBwbHlCdXR0b24gPSBwYXBlci5odG1sKCdkaXYnLCB7XG4gICAgICAgIHdpZHRoOiA1MCxcbiAgICAgICAgaGVpZ2h0OiAyMCxcbiAgICAgICAgeDogMTIwLFxuICAgICAgICB5OiAzMCxcbiAgICAgICAgZmlsbDogJyM1NTU1NTUnXG4gICAgICB9LCB7XG4gICAgICAgIGZvbnRTaXplOiAxMCArICdweCcsXG4gICAgICAgIGxpbmVIZWlnaHQ6IDE1ICsgJ3B4JyxcbiAgICAgICAgZm9udEZhbWlseTogJ0x1Y2lkYSBHcmFuZGUnLFxuICAgICAgICBmaWxsOiAnI2VhZWFlYScsXG4gICAgICAgIGNvbG9yOiAnI2VhZWFlYScsXG4gICAgICAgIHN0cm9rZTogJyNlYWVhZWEnLFxuICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgfSwgYm94KTtcblxuICAgICAgYXBwbHlCdXR0b24ub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBib3guaGlkZSgpO1xuICAgICAgICBjYWxsYmFjayhpbnB1dEZpZWxkLnZhbCgpKTtcbiAgICAgIH0pO1xuICAgICAgYXBwbHlCdXR0b24uYXR0cih7XG4gICAgICAgIHRleHQ6ICdBcHBseSdcbiAgICAgIH0pO1xuICAgICAgaW5wdXRGaWVsZC5lbGVtZW50LmZvY3VzKCk7XG4gICAgICBmdW5jdGlvbiBpbnB1dEZpZWxkTnVtYmVySGFuZGxlciAoKSB7XG4gICAgICAgIGlucHV0RmllbGQuZWxlbWVudC52YWx1ZSA9IGlucHV0RmllbGQuZWxlbWVudC52YWx1ZS5yZXBsYWNlKC9bXlxcZC4tXS9nLCAnJyk7XG4gICAgICB9XG4gICAgICBpbnB1dEZpZWxkLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBpbnB1dEZpZWxkTnVtYmVySGFuZGxlcik7XG4gICAgICBjcm9zcy5lbGVtZW50LnN0eWxlWydwb3NpdGlvbiddID0gJ3JlbGF0aXZlJztcbiAgICAgIGNyb3NzLmVsZW1lbnQuc3R5bGVbJ2JhY2tncm91bmRDb2xvciddID0gJyNkMmQyZDInO1xuICAgICAgY3Jvc3MuZWxlbWVudC5zdHlsZVsnYm9yZGVyJ10gPSAnMnB4IHNvbGlkICNjYmNiY2InO1xuICAgICAgY3Jvc3MuZWxlbWVudC5zdHlsZVsncGFkZGluZyddID0gJzBweCAwcHggMy41cHggMnB4JztcbiAgICAgIGNyb3NzLmVsZW1lbnQuc3R5bGVbJ2NvbG9yJ10gPSAnIzhjOGM4Yyc7XG4gICAgICBjcm9zcy5lbGVtZW50LnN0eWxlWydtYXJnaW4nXSA9ICcxcHggMnB4JztcbiAgICAgIGNyb3NzLmVsZW1lbnQuc3R5bGVbJ2Zsb2F0J10gPSAncmlnaHQnO1xuICAgICAgaW5wdXRGaWVsZC5lbGVtZW50LnN0eWxlWydtYXJnaW5Ub3AnXSA9ICc4cHgnO1xuICAgICAgaW5wdXRGaWVsZC5lbGVtZW50LnN0eWxlWydib3JkZXInXSA9ICcycHggc29saWQgI2RhZGJkYSc7XG4gICAgICBhcHBseUJ1dHRvbi5lbGVtZW50LnN0eWxlWydtYXJnaW5Ub3AnXSA9ICc4cHgnO1xuICAgICAgYm94LmVsZW1lbnQuc3R5bGVbJ2JvcmRlciddID0gJzFweCBzb2xpZCAjZDRkMmQzJztcbiAgICAgIGhlYWRlci5lbGVtZW50LnN0eWxlWydib3JkZXInXSA9ICcxcHggc29saWQgI2Q0ZDJkMyc7XG4gICAgICBoZWFkZXIuZWxlbWVudC5zdHlsZVsnd2lkdGgnXSA9ICcxNzlweCc7XG4gICAgICBoZWFkZXJUZXh0LmVsZW1lbnQuc3R5bGVbJ2ZvbnRTaXplJ10gPSAnMTEuNXB4JztcbiAgICAgIGhlYWRlclRleHQuZWxlbWVudC5zdHlsZVsnbWFyZ2luVG9wJ10gPSAnMC41cHgnO1xuICAgICAgaGVhZGVyVGV4dC5lbGVtZW50LnN0eWxlWydjb2xvciddID0gJyM2NzY3NjcnO1xuICAgICAgaGVhZGVyLmVsZW1lbnQuc3R5bGVbJ2ZvbnRGYW1pbHknXSA9ICdNeXJpYWRQcm8nO1xuICAgICAgYXBwbHlCdXR0b24uZWxlbWVudC5zdHlsZVsndGV4dEFsaWduJ10gPSAnY2VudGVyJztcbiAgICAgIGFwcGx5QnV0dG9uLmVsZW1lbnQuc3R5bGVbJ2ZvbnRTaXplJ10gPSAnMTFweCc7XG4gICAgICBhcHBseUJ1dHRvbi5lbGVtZW50LnN0eWxlWydwYWRkaW5nVG9wJ10gPSAnM3B4JztcbiAgICAgIGFwcGx5QnV0dG9uLmVsZW1lbnQuc3R5bGVbJ2JvcmRlclJhZGl1cyddID0gJzNweCc7XG4gICAgICBhcHBseUJ1dHRvbi5lbGVtZW50LnN0eWxlWydjb2xvciddID0gJyNlNGU0ZTQnO1xuICAgIH07XG5cbiAgICBmb3IgKGxldCBpIGluIGdhT3B0aW9uc09iaikge1xuICAgICAgbGV0IGtleSxcbiAgICAgICAgb2JqID0ge30sXG4gICAgICAgIHN1Yk9iaiA9IHt9O1xuICAgICAgaWYgKGdhT3B0aW9uc09ialtpXSA9PT0gJ2RpYWxvZ0JveCcpIHtcbiAgICAgICAga2V5ID0gJyZuYnNwOyAmbmJzcDsgJyArIGk7XG4gICAgICAgIG9ialtrZXldID0ge307XG4gICAgICAgIG9ialtrZXldID0ge1xuICAgICAgICAgIHN0eWxlOiBzdWJDYXRTdHlsZSxcbiAgICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBsZXQgcG9wdXBWYWwgPSBwb3B1cChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICAvLyAgIHNlbGYuYW5hbHlzZXIocGFyc2VJbnQoc3RyKSk7XG4gICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgICAgIGlmIChpID09PSAnRml4ZWQtTnVtYmVyJykge1xuICAgICAgICAgICAgICAvLyBzZWxmLmFuYWx5c2VyKHBhcnNlSW50KHdpbmRvdy5wcm9tcHQoJ0VudGVyIHZhbHVlJykpKTtcbiAgICAgICAgICAgICAgbGV0IHBvcHVwVmFsID0gcG9wdXAoZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgICAgIHNlbGYuYW5hbHlzZXIocGFyc2VJbnQoc3RyKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpID09PSAnUG9zaXRpb24nKSB7XG4gICAgICAgICAgICAgIGxldCBwb3B1cFZhbCA9IHBvcHVwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmFuYWx5c2VyKHtwb3NpdGlvbjogc3RyfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYWN0aW9uOiAnY2xpY2snXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXkgPSAnJiM5NjY2Jm5ic3A7ICcgKyBpO1xuICAgICAgICBvYmpba2V5XSA9IHt9O1xuICAgICAgICBvYmpba2V5XS5hY3Rpb24gPSAnY2xpY2snO1xuICAgICAgICBvYmpba2V5XS5zdHlsZSA9IHN1YkNhdFN0eWxlO1xuICAgICAgICBvYmpba2V5XS5oYW5kbGVyID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZ2FPcHRpb25zT2JqW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgbGV0IHN1Yk1lbnVOYW1lID0gZ2FPcHRpb25zT2JqW2ldW2pdO1xuICAgICAgICAgIHN1Yk9iaiA9IHt9O1xuICAgICAgICAgIHN1Yk9ialsnJm5ic3A7JyArIHN1Yk1lbnVOYW1lXSA9IHt9O1xuICAgICAgICAgIHN1Yk9ialsnJm5ic3A7JyArIHN1Yk1lbnVOYW1lXS5oYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gWydNaW5pbXVtJywgJ01heGltdW0nLCAnTWVhbicsICdNZWRpYW4nLCAnU3RhbmRhcmQgRGV2aWF0aW9uJ11cbiAgICAgICAgICAgIC8vIFsnUHJldmlvdXMgRGF0YXNldCcsICdOZXh0IERhdGFzZXQnXVxuICAgICAgICAgICAgLy8gWydOZXh0JywgJ1ByZXZpb3VzJ11cbiAgICAgICAgICAgIGlmIChzdWJNZW51TmFtZSA9PT0gJ01pbmltdW0nIHx8XG4gICAgICAgICAgICAgIHN1Yk1lbnVOYW1lID09PSAnTWF4aW11bScgfHwgc3ViTWVudU5hbWUgPT09ICdNZWFuJyB8fFxuICAgICAgICAgICAgICBzdWJNZW51TmFtZSA9PT0gJ01lZGlhbicgfHwgc3ViTWVudU5hbWUgPT09ICdTdGFuZGFyZCBEZXZpYXRpb24nKSB7XG4gICAgICAgICAgICAgIHNlbGYuYW5hbHlzZXIoc3ViTWVudU5hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdWJNZW51TmFtZSA9PT0gJ1ByZXZpb3VzIERhdGFzZXQnKSB7XG4gICAgICAgICAgICAgIHNlbGYuYW5hbHlzZXIoe3JlbGRhdGFzZXRwb3NpdGlvbjogLTF9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3ViTWVudU5hbWUgPT09ICdOZXh0IERhdGFzZXQnKSB7XG4gICAgICAgICAgICAgIHNlbGYuYW5hbHlzZXIoe3JlbGRhdGFzZXRwb3NpdGlvbjogMX0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdWJNZW51TmFtZSA9PT0gJ05leHQnKSB7XG4gICAgICAgICAgICAgIHNlbGYuYW5hbHlzZXIoe3JlbHBvc2l0aW9uOiAtMX0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdWJNZW51TmFtZSA9PT0gJ1ByZXZpb3VzJykge1xuICAgICAgICAgICAgICBzZWxmLmFuYWx5c2VyKHtyZWxwb3NpdGlvbjogMX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgc3ViT2JqWycmbmJzcDsnICsgc3ViTWVudU5hbWVdLmFjdGlvbiA9ICdjbGljayc7XG4gICAgICAgICAgc3ViT2JqWycmbmJzcDsnICsgc3ViTWVudU5hbWVdLnN0eWxlID0gc3ViQ2F0U3R5bGU7XG4gICAgICAgICAgb2JqW2tleV0uaGFuZGxlci5wdXNoKHN1Yk9iaik7XG4gICAgICAgICAgaWYgKGogIT09IGdhT3B0aW9uc09ialtpXS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBvYmpba2V5XS5oYW5kbGVyLnB1c2goe1xuICAgICAgICAgICAgICAnJzoge1xuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZDVkMmQyJyxcbiAgICAgICAgICAgICAgICAgIGhlaWdodDogJzFweCcsXG4gICAgICAgICAgICAgICAgICBtYXJnaW46ICcxcHgnLFxuICAgICAgICAgICAgICAgICAgcGFkZGluZzogJzBweCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29udGV4dEFycmF5LnB1c2gob2JqKTtcbiAgICAgIGNvbnRleHRBcnJheS5wdXNoKHtcbiAgICAgICAgJyc6IHtcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2Q1ZDJkMicsXG4gICAgICAgICAgICBoZWlnaHQ6ICcxcHgnLFxuICAgICAgICAgICAgbWFyZ2luOiAnMXB4JyxcbiAgICAgICAgICAgIHBhZGRpbmc6ICcwcHgnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb250ZXh0QXJyYXkucHVzaCh7XG4gICAgICAnJm5ic3A7ICZuYnNwOyBSZXNldCc6IHtcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYuYW5hbHlzZXIoJ3Jlc2V0Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIGFjdGlvbjogJ2NsaWNrJyxcbiAgICAgICAgc3R5bGU6IHN1YkNhdFN0eWxlXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb250ZXh0TWVudS5hcHBlbmRBc0xpc3QoY29udGV4dEFycmF5KTtcblxuICAgIHRoaXMuU3ltYm9sU3RvcmUucmVnaXN0ZXIoJ0NvbnRleHRJY29uJywgZnVuY3Rpb24gKHBvc3gsIHBvc3ksIHJhZCkge1xuICAgICAgdmFyIHggPSBwb3N4LFxuICAgICAgICB5ID0gcG9zeSxcbiAgICAgICAgciA9IHJhZCAqIDIsXG4gICAgICAgIHNwYWNlID0gTWF0aC5yb3VuZChyIC8gNCksXG4gICAgICAgIGhhbGZXaWR0aCA9IE1hdGgucm91bmQociAvIDIpICogMC43LFxuICAgICAgICBzdGFydFggPSAoeCAtIGhhbGZXaWR0aCksXG4gICAgICAgIGVuZFggPSAoeCArIGhhbGZXaWR0aCksXG4gICAgICAgIHN0YXJ0WSA9ICh5ICsgc3BhY2UpLFxuICAgICAgICBlbmRZID0gKHkgLSBzcGFjZSk7XG4gICAgICByZXR1cm4gWydNJywgc3RhcnRYLCB5LCAnTCcsIGVuZFgsIHksICdNJywgc3RhcnRYLCBzdGFydFksICdMJywgZW5kWCwgc3RhcnRZLCAnTScsIHN0YXJ0WCwgZW5kWSwgJ0wnLCBlbmRYLCBlbmRZXTtcbiAgICB9KTtcblxuICAgIGdyb3VwLmFkZFN5bWJvbChjb250ZXh0TWVudSk7XG4gICAgdG9vbGJhci5hZGRDb21wb25lbnQoZ3JvdXApO1xuICAgIHJldHVybiB0b29sYmFyO1xuICB9O1xuXG4gIExlZ2VuZEV4dC5wcm90b3R5cGUuZ2V0TG9naWNhbFNwYWNlID0gZnVuY3Rpb24gKGF2YWlsYWJsZVdpZHRoLCBhdmFpbGFibGVIZWlnaHQpIHtcbiAgICBhdmFpbGFibGVXaWR0aCAvPSAyO1xuICAgIHZhciBsb2dpY2FsU3BhY2UsXG4gICAgICB3aWR0aCA9IDAsXG4gICAgICBoZWlnaHQgPSAwLFxuICAgICAgaSxcbiAgICAgIGxuO1xuXG4gICAgZm9yIChpID0gMCwgbG4gPSB0aGlzLnRvb2xiYXJzLmxlbmd0aDsgaSA8IGxuOyBpKyspIHtcbiAgICAgIGxvZ2ljYWxTcGFjZSA9IHRoaXMudG9vbGJhcnNbaV0uZ2V0TG9naWNhbFNwYWNlKGF2YWlsYWJsZVdpZHRoLCBhdmFpbGFibGVIZWlnaHQpO1xuICAgICAgd2lkdGggPSBNYXRoLm1heChsb2dpY2FsU3BhY2Uud2lkdGgsIHdpZHRoKTtcbiAgICAgIGhlaWdodCArPSBsb2dpY2FsU3BhY2UuaGVpZ2h0O1xuICAgICAgdGhpcy50b29sYmFyc1tpXS53aWR0aCA9IGxvZ2ljYWxTcGFjZS53aWR0aDtcbiAgICAgIHRoaXMudG9vbGJhcnNbaV0uaGVpZ2h0ID0gbG9naWNhbFNwYWNlLmhlaWdodDtcbiAgICB9XG4gICAgaGVpZ2h0ICs9IHRoaXMucGFkZGluZztcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHdpZHRoID4gYXZhaWxhYmxlV2lkdGggPyAwIDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCA+IGF2YWlsYWJsZUhlaWdodCA/IDAgOiBoZWlnaHRcbiAgICB9O1xuICB9O1xuXG4gIExlZ2VuZEV4dC5wcm90b3R5cGUucGxhY2VJbkNhbnZhcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5wYWRkaW5nID0gNTtcbiAgICBzZWxmLnNwYWNlTWFuYWdlckluc3RhbmNlLmFkZChbe1xuICAgICAgbmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1Rvb2xCb3hFeHQnO1xuICAgICAgfSxcbiAgICAgIHJlZjogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqWycwJ107XG4gICAgICB9LFxuICAgICAgc2VsZjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH0sXG4gICAgICBwcmlvcml0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH0sXG4gICAgICBsYXlvdXQ6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iai5pbmxpbmU7XG4gICAgICB9LFxuICAgICAgb3JpZW50YXRpb246IFt7XG4gICAgICAgIHR5cGU6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICByZXR1cm4gb2JqLmhvcml6b250YWw7XG4gICAgICAgIH0sXG4gICAgICAgIHBvc2l0aW9uOiBbe1xuICAgICAgICAgIHR5cGU6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoudG9wO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWxpZ25tZW50OiBbe1xuICAgICAgICAgICAgdHlwZTogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICByZXR1cm4gb2JqLnJpZ2h0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudENvbXBvbmVudEdyb3VwKCk7XG4gICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldExvZ2ljYWxTcGFjZShwYXJlbnQuZ2V0V2lkdGgoKSwgcGFyZW50LmdldEhlaWdodCgpKTtcbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfV1cbiAgICAgICAgfV1cbiAgICAgIH1dXG4gICAgfV0pO1xuICB9O1xuXG4gIExlZ2VuZEV4dC5wcm90b3R5cGUuc2V0RHJhd2luZ0NvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgZ3JvdXApIHtcbiAgICB2YXIgbWVzID0gdGhpcy5tZWFzdXJlbWVudDtcbiAgICBtZXMueCA9IHg7XG4gICAgbWVzLnkgPSB5O1xuICAgIG1lcy53aWR0aCA9IHdpZHRoO1xuICAgIG1lcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICB0aGlzLnBhcmVudEdyb3VwID0gZ3JvdXA7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBMZWdlbmRFeHQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgZ3JvdXApIHtcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSB0aGlzLm1lYXN1cmVtZW50LFxuICAgICAgdG9vbGJhcnMgPSB0aGlzLnRvb2xiYXJzLFxuICAgICAgbG4sXG4gICAgICBpLFxuICAgICAgdG9vbGJhcjtcbiAgICB4ID0geCA9PT0gdW5kZWZpbmVkID8gbWVhc3VyZW1lbnQueCA6IHg7XG4gICAgeSA9IHkgPT09IHVuZGVmaW5lZCA/IG1lYXN1cmVtZW50LnkgOiB5O1xuICAgIHdpZHRoID0gd2lkdGggPT09IHVuZGVmaW5lZCA/IG1lYXN1cmVtZW50LndpZHRoIDogd2lkdGg7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0ID09PSB1bmRlZmluZWQgPyBtZWFzdXJlbWVudC5oZWlnaHQgOiBoZWlnaHQ7XG4gICAgZ3JvdXAgPSBncm91cCA9PT0gdW5kZWZpbmVkID8gdGhpcy5wYXJlbnRHcm91cCA6IGdyb3VwO1xuICAgIGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxuID0gdG9vbGJhcnMubGVuZ3RoOyBpIDwgbG47IGkrKykge1xuICAgICAgICB0b29sYmFyID0gdG9vbGJhcnNbaV07XG4gICAgICAgIHRvb2xiYXIuZHJhdyh4LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgRnVzaW9uQ2hhcnRzLnJlZ2lzdGVyQ29tcG9uZW50KCdleHRlbnNpb25zJywgJ2xlZ2VuZEV4dCcsIExlZ2VuZEV4dCk7XG59XSk7XG5cbid1c2Ugc3RyaWN0JztcbmNsYXNzIEdyb3d0aEFuYWx5c2VyIHtcbiAgY29uc3RydWN0b3IgKGRhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhLm1hcCgoYSkgPT4ge1xuICAgICAgcmV0dXJuIGEubWFwKChiKSA9PiB7IHJldHVybiBiOyB9KTtcbiAgICB9KTtcbiAgICB0aGlzLkZvcm11bGFlID0gRm9ybXVsYWU7XG4gIH1cbiAgYW5hbHlzZSAobW9kZSkge1xuICAgIGxldCBpID0gMCxcbiAgICAgIGlpID0gMCxcbiAgICAgIGogPSAwLFxuICAgICAgamogPSAwLFxuICAgICAgbnVtID0gMCxcbiAgICAgIGNoZWNrQXJyID0gW10sXG4gICAgICBjaGVja051bSA9IDAsXG4gICAgICBkYXRhQXIgPSB0aGlzLmRhdGEsXG4gICAgICBuRGF0YUFyID0gW10sXG4gICAgICB0ZW1wQXIgPSBbXSxcbiAgICAgIHRlbXAgPSAwO1xuICAgIGlmICh0eXBlb2YgbW9kZSA9PT0gJ3N0cmluZycgJiYgbW9kZS50b0xvd2VyQ2FzZSgpID09PSAncmVzZXQnKSB7XG4gICAgICByZXR1cm4gZGF0YUFyLm1hcCgoYSkgPT4ge1xuICAgICAgICByZXR1cm4gYS5tYXAoKGIpID0+IHsgcmV0dXJuIGI7IH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghaXNOYU4obW9kZSkpIHsgLy8gSGFuZGxpbmcgYSBudW1iZXJcbiAgICAgIGNoZWNrTnVtID0gK21vZGU7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGRhdGFBci5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHRlbXBBciA9IFtdO1xuICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGRhdGFBcltpXS5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgbnVtID0gZGF0YUFyW2ldW2pdO1xuICAgICAgICAgIHRlbXBBci5wdXNoKDEwMCAqIChudW0gLSBjaGVja051bSkgLyBjaGVja051bSk7XG4gICAgICAgIH1cbiAgICAgICAgbkRhdGFBci5wdXNoKHRlbXBBcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG1vZGUgPSB0aGlzLkZvcm11bGFlW21vZGVdO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBkYXRhQXIubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB0ZW1wQXIgPSBbXTtcbiAgICAgICAgY2hlY2tOdW0gPSBtb2RlKGRhdGFBcltpXSk7XG4gICAgICAgIGZvciAoaiA9IDAsIGpqID0gZGF0YUFyW2ldLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBudW0gPSBkYXRhQXJbaV1bal07XG4gICAgICAgICAgaWYgKGNoZWNrTnVtID09PSAwKSB7XG4gICAgICAgICAgICB0ZW1wID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wID0gMTAwICogKG51bSAtIGNoZWNrTnVtKSAvIGNoZWNrTnVtO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZW1wQXIucHVzaCh0ZW1wKTtcbiAgICAgICAgfVxuICAgICAgICBuRGF0YUFyLnB1c2godGVtcEFyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc05hTihtb2RlLnJlbHBvc2l0aW9uKSkge1xuICAgICAgbW9kZSA9IG1vZGUucmVscG9zaXRpb247XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGRhdGFBci5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHRlbXBBciA9IFtdO1xuICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGRhdGFBcltpXS5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgbnVtID0gZGF0YUFyW2ldW2pdO1xuICAgICAgICAgIGlmIChqICsgbW9kZSA+PSAwICYmIGogKyBtb2RlIDwgamopIHtcbiAgICAgICAgICAgIGNoZWNrTnVtID0gZGF0YUFyW2ldW2ogKyBtb2RlXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tOdW0gPSBudW07XG4gICAgICAgICAgfVxuICAgICAgICAgIHRlbXBBci5wdXNoKDEwMCAqIChudW0gLSBjaGVja051bSkgLyBjaGVja051bSk7XG4gICAgICAgIH1cbiAgICAgICAgbkRhdGFBci5wdXNoKHRlbXBBcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNOYU4obW9kZS5wb3NpdGlvbikpIHtcbiAgICAgIG1vZGUgPSBtb2RlLnBvc2l0aW9uO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBkYXRhQXIubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB0ZW1wQXIgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgamogPSBkYXRhQXJbaV0ubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICAgIG51bSA9IGRhdGFBcltpXVtqXTtcbiAgICAgICAgICBpZiAobW9kZSA+PSAwICYmIG1vZGUgPCBqaikge1xuICAgICAgICAgICAgY2hlY2tOdW0gPSBkYXRhQXJbaV1bbW9kZV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrTnVtID0gbnVtO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZW1wQXIucHVzaCgxMDAgKiAobnVtIC0gY2hlY2tOdW0pIC8gY2hlY2tOdW0pO1xuICAgICAgICB9XG4gICAgICAgIG5EYXRhQXIucHVzaCh0ZW1wQXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzTmFOKG1vZGUucmVsZGF0YXNldHBvc2l0aW9uKSkge1xuICAgICAgbW9kZSA9IG1vZGUucmVsZGF0YXNldHBvc2l0aW9uO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBkYXRhQXIubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB0ZW1wQXIgPSBbXTtcbiAgICAgICAgaWYgKGkgKyBtb2RlID49IDAgJiYgaSArIG1vZGUgPCBpaSkge1xuICAgICAgICAgIGNoZWNrQXJyID0gZGF0YUFyW2kgKyBtb2RlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGVja0FyciA9IGRhdGFBcltpXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGRhdGFBcltpXS5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgY2hlY2tOdW0gPSBjaGVja0FycltqXTtcbiAgICAgICAgICBudW0gPSBkYXRhQXJbaV1bal07XG4gICAgICAgICAgdGVtcEFyLnB1c2goMTAwICogKG51bSAtIGNoZWNrTnVtKSAvIG51bSk7XG4gICAgICAgIH1cbiAgICAgICAgbkRhdGFBci5wdXNoKHRlbXBBcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGlpID0gbkRhdGFBci5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBmb3IgKGogPSAwLCBqaiA9IG5EYXRhQXJbaV0ubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShuRGF0YUFyW2ldW2pdKSkge1xuICAgICAgICAgIG5EYXRhQXJbaV1bal0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuRGF0YUFyO1xuICB9XG59XG5cbnZhciBGb3JtdWxhZSA9IHtcbiAgTWluaW11bTogKGFycikgPT4ge1xuICAgIHJldHVybiBhcnIucmVkdWNlKChhLCBiKSA9PiB7XG4gICAgICByZXR1cm4gYSA+IGIgPyBiIDogYTtcbiAgICB9KTtcbiAgfSxcbiAgTWF4aW11bTogKGFycikgPT4ge1xuICAgIHJldHVybiBhcnIucmVkdWNlKChhLCBiKSA9PiB7XG4gICAgICByZXR1cm4gYSA8IGIgPyBiIDogYTtcbiAgICB9KTtcbiAgfSxcbiAgTWVhbjogKGFycikgPT4ge1xuICAgIHJldHVybiBhcnIucmVkdWNlKChhLCBiKSA9PiB7XG4gICAgICByZXR1cm4gYSArIGI7XG4gICAgfSkgLyBhcnIubGVuZ3RoO1xuICB9LFxuICBNZWRpYW46IChhcnIpID0+IHtcbiAgICByZXR1cm4gYXJyLm1hcCgoYSkgPT4gYSkuc29ydCgoYSwgYikgPT4geyByZXR1cm4gYSAtIGI7IH0pW2Fyci5sZW5ndGggLyAyXTtcbiAgfSxcbiAgJ1N0YW5kYXJkIERldmlhdGlvbic6ICh2YWx1ZXMpID0+IHtcbiAgICBmdW5jdGlvbiBhdmVyYWdlIChkYXRhKSB7XG4gICAgICB2YXIgc3VtLCBhdmc7XG4gICAgICBzdW0gPSBkYXRhLnJlZHVjZShmdW5jdGlvbiAoc3VtLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gc3VtICsgdmFsdWU7XG4gICAgICB9LCAwKTtcblxuICAgICAgYXZnID0gc3VtIC8gZGF0YS5sZW5ndGg7XG4gICAgICByZXR1cm4gYXZnO1xuICAgIH1cbiAgICB2YXIgYXZnID0gMCxcbiAgICAgIHNxdWFyZURpZmZzID0gMCxcbiAgICAgIHNxckRpZmYgPSAwLFxuICAgICAgYXZnU3F1YXJlRGlmZiA9IDAsXG4gICAgICBzdGREZXYgPSAwLFxuICAgICAgZGlmZiA9IDA7XG4gICAgYXZnID0gYXZlcmFnZSh2YWx1ZXMpO1xuICAgIHNxdWFyZURpZmZzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGRpZmYgPSB2YWx1ZSAtIGF2ZztcbiAgICAgIHNxckRpZmYgPSBkaWZmICogZGlmZjtcbiAgICAgIHJldHVybiBzcXJEaWZmO1xuICAgIH0pO1xuICAgIGF2Z1NxdWFyZURpZmYgPSBhdmVyYWdlKHNxdWFyZURpZmZzKTtcbiAgICBzdGREZXYgPSBNYXRoLnNxcnQoYXZnU3F1YXJlRGlmZik7XG4gICAgcmV0dXJuIHN0ZERldjtcbiAgfVxufTtcbn0odGhpcywgZG9jdW1lbnQpKTtcbiJdLCJmaWxlIjoiZ3Jvd3RoLWFuYWx5c2VyLWVzNi5taW4uanMifQ==
