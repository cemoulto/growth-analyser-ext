(function(window, document, undefined) {
"use strict";

FusionCharts.register('extension', ['private', 'legend-ext', function () {
  function LegendExt () {}
  LegendExt.prototype.constructor = LegendExt;

  LegendExt.prototype.init = function (require) {
    var instance = this,
      saveTo = 'tsObject',
      requiredParams = [
        'chartInstance',
        'graphics',
        'globalReactiveModel',
        function acquire () {
          let i = 0,
            ii = requiredParams.length - 1,
            param = '';
          instance[saveTo] = instance[saveTo] || {};
          instance.requiredParams = {};
          for (i = 0; i < ii; ++i) {
            param = requiredParams[i];
            instance[saveTo][param] = arguments[i];
          }
          onInit(instance[saveTo]);
        }
      ];
    require(requiredParams);
    // Init additional logic here
    function onInit (params) {
      let chartInstance = params.chartInstance,
        store = chartInstance.apiInstance.getComponentStore(),
        storeDatasets = store.getAllDatasets(),
        allDatasetArr = [],
        i = 0,
        ii = 0,
        j = 0,
        currentDs = {},
        growthAnalyserArr = [];
      for (i = 0; storeDatasets[i]; ++i) {
        allDatasetArr[i] = [];
        currentDs = storeDatasets[i];
        if (currentDs && currentDs.series) {
          for (j = 0; currentDs.series[j] && currentDs.series[j].data; ++j) {
            allDatasetArr[i].push(currentDs.series[j].data);
          }
        }
      }
      // Getting growth analyser object from dataset array
      for (i = 0, ii = allDatasetArr.length; i < ii; ++i) {
        growthAnalyserArr.push(new GrowthAnalyser(allDatasetArr[i]));
      }
      // Saving retrieved growth analyser array to instance
      instance.tsObject.growthAnalyserArr = growthAnalyserArr;
      // saving dataset to instance
      instance.tsObject.dataStore = storeDatasets;
      window.g = params.globalReactiveModel;
    }
    window.a = this;
    return this;
  };

  LegendExt.prototype.renderChange = function () {
    var chartInstance = this.tsObject.chartInstance,
      componentStore = chartInstance.apiInstance.getComponentStore(),
      i = 0;
    for (i = 0; componentStore.getCanvasByIndex(i); ++i) {
      componentStore.getCanvasByIndex(i).getComposition().PlotManager.plot();
    }
  };

  LegendExt.prototype.analyser = function (mode) {
    var i = 0,
      ii = 0,
      j = 0,
      jj = 0,
      dataStore = this.tsObject.dataStore,
      gaArr = this.tsObject.growthAnalyserArr,
      gaOb = {};
    for (i = 0, ii = gaArr.length; i < ii; ++i) {
      gaOb = gaArr[i].analyse(mode);
      for (j = 0, jj = gaOb.length; j < jj; ++j) {
        dataStore[i].series[j].data = gaOb[j];
      }
    }
    // Rendering the change
    this.renderChange();
  };

  LegendExt.prototype.getLogicalSpace = function () {
    return {
      width: 70,
      height: 30
    };
  };

  LegendExt.prototype.placeInCanvas = function (containerInstance) {
    var logicalSpace = this.getLogicalSpace();

    containerInstance.addComponent([{
      pIndex: 3,
      type: 'HorizontalSwimLane',
      components: [{
        type: 'VerticalSwimLane',
        components: [{
          width: logicalSpace.width,
          height: logicalSpace.height,
          name: 'LegendExt',
          x: function () {
            return this.get('x', 'Canvas0Group') + this.get('width', 'Canvas0Group') / 2 - logicalSpace.width;
          },
          type: 'Modules',
          ref: this
        }]
      }]
    }], 0);
  };

  LegendExt.prototype.draw = function (x, y, width, height) {
    this.tsObject.graphics.paper.rect(0, 0, width, height);
  };

  LegendExt.prototype.dispose = function () {

  };

  FusionCharts.registerComponent('extensions', 'legendExt', LegendExt);
}]);

'use strict';
class GrowthAnalyser {
  constructor (data) {
    this.data = data;
  }
  analyse (mode) {
    let i = 0,
      ii = 0,
      j = 0,
      jj = 0,
      num = 0,
      checkArr = [],
      checkNum = 0,
      dataAr = this.data,
      nDataAr = [],
      tempAr = [];

    if (!isNaN(mode)) { // Handling a number
      checkNum = mode;
      for (i = 0, ii = dataAr.length; i < ii; ++i) {
        tempAr = [];
        for (j = 0, jj = dataAr[i].length; j < jj; ++j) {
          num = dataAr[i][j];
          tempAr.push(100 * (num - checkNum) / checkNum);
        }
        nDataAr.push(tempAr);
      }
    } else if (typeof mode === 'function') {
      for (i = 0, ii = dataAr.length; i < ii; ++i) {
        tempAr = [];
        checkNum = mode(dataAr[i]);
        for (j = 0, jj = dataAr[i].length; j < jj; ++j) {
          num = dataAr[i][j];
          tempAr.push(100 * (num - checkNum) / checkNum);
        }
        nDataAr.push(tempAr);
      }
    } else if (!isNaN(mode.relposition)) {
      mode = mode.relposition;
      for (i = 0, ii = dataAr.length; i < ii; ++i) {
        tempAr = [];
        for (j = 0, jj = dataAr[i].length; j < jj; ++j) {
          num = dataAr[i][j];
          if (j + mode >= 0 && j + mode < jj) {
            checkNum = dataAr[i][j + mode];
          } else {
            checkNum = num;
          }
          tempAr.push(100 * (num - checkNum) / checkNum);
        }
        nDataAr.push(tempAr);
      }
    } else if (!isNaN(mode.position)) {
      mode = mode.position;
      for (i = 0, ii = dataAr.length; i < ii; ++i) {
        tempAr = [];
        for (j = 0, jj = dataAr[i].length; j < jj; ++j) {
          num = dataAr[i][j];
          if (mode >= 0 && mode < jj) {
            checkNum = dataAr[i][mode];
          } else {
            checkNum = num;
          }
          tempAr.push(100 * (num - checkNum) / checkNum);
        }
        nDataAr.push(tempAr);
      }
    } else if (!isNaN(mode.reldatasetposition)) {
      mode = mode.reldatasetposition;
      for (i = 0, ii = dataAr.length; i < ii; ++i) {
        tempAr = [];
        if (i + mode >= 0 && i + mode < ii) {
          checkArr = dataAr[i + mode];
        } else {
          checkArr = dataAr[i];
        }
        for (j = 0, jj = dataAr[i].length; j < jj; ++j) {
          checkNum = checkArr[j];
          num = dataAr[i][j];
          tempAr.push(100 * (num - checkNum) / num);
        }
        nDataAr.push(tempAr);
      }
    }
    return nDataAr;
  }
}
}(this, document));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJjYW52YXNsaXRlLWVzNi5taW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkZ1c2lvbkNoYXJ0cy5yZWdpc3RlcignZXh0ZW5zaW9uJywgWydwcml2YXRlJywgJ2xlZ2VuZC1leHQnLCBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExlZ2VuZEV4dCAoKSB7fVxuICBMZWdlbmRFeHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGVnZW5kRXh0O1xuXG4gIExlZ2VuZEV4dC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChyZXF1aXJlKSB7XG4gICAgdmFyIGluc3RhbmNlID0gdGhpcyxcbiAgICAgIHNhdmVUbyA9ICd0c09iamVjdCcsXG4gICAgICByZXF1aXJlZFBhcmFtcyA9IFtcbiAgICAgICAgJ2NoYXJ0SW5zdGFuY2UnLFxuICAgICAgICAnZ3JhcGhpY3MnLFxuICAgICAgICAnZ2xvYmFsUmVhY3RpdmVNb2RlbCcsXG4gICAgICAgIGZ1bmN0aW9uIGFjcXVpcmUgKCkge1xuICAgICAgICAgIGxldCBpID0gMCxcbiAgICAgICAgICAgIGlpID0gcmVxdWlyZWRQYXJhbXMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIHBhcmFtID0gJyc7XG4gICAgICAgICAgaW5zdGFuY2Vbc2F2ZVRvXSA9IGluc3RhbmNlW3NhdmVUb10gfHwge307XG4gICAgICAgICAgaW5zdGFuY2UucmVxdWlyZWRQYXJhbXMgPSB7fTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgcGFyYW0gPSByZXF1aXJlZFBhcmFtc1tpXTtcbiAgICAgICAgICAgIGluc3RhbmNlW3NhdmVUb11bcGFyYW1dID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvbkluaXQoaW5zdGFuY2Vbc2F2ZVRvXSk7XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgcmVxdWlyZShyZXF1aXJlZFBhcmFtcyk7XG4gICAgLy8gSW5pdCBhZGRpdGlvbmFsIGxvZ2ljIGhlcmVcbiAgICBmdW5jdGlvbiBvbkluaXQgKHBhcmFtcykge1xuICAgICAgbGV0IGNoYXJ0SW5zdGFuY2UgPSBwYXJhbXMuY2hhcnRJbnN0YW5jZSxcbiAgICAgICAgc3RvcmUgPSBjaGFydEluc3RhbmNlLmFwaUluc3RhbmNlLmdldENvbXBvbmVudFN0b3JlKCksXG4gICAgICAgIHN0b3JlRGF0YXNldHMgPSBzdG9yZS5nZXRBbGxEYXRhc2V0cygpLFxuICAgICAgICBhbGxEYXRhc2V0QXJyID0gW10sXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBpaSA9IDAsXG4gICAgICAgIGogPSAwLFxuICAgICAgICBjdXJyZW50RHMgPSB7fSxcbiAgICAgICAgZ3Jvd3RoQW5hbHlzZXJBcnIgPSBbXTtcbiAgICAgIGZvciAoaSA9IDA7IHN0b3JlRGF0YXNldHNbaV07ICsraSkge1xuICAgICAgICBhbGxEYXRhc2V0QXJyW2ldID0gW107XG4gICAgICAgIGN1cnJlbnREcyA9IHN0b3JlRGF0YXNldHNbaV07XG4gICAgICAgIGlmIChjdXJyZW50RHMgJiYgY3VycmVudERzLnNlcmllcykge1xuICAgICAgICAgIGZvciAoaiA9IDA7IGN1cnJlbnREcy5zZXJpZXNbal0gJiYgY3VycmVudERzLnNlcmllc1tqXS5kYXRhOyArK2opIHtcbiAgICAgICAgICAgIGFsbERhdGFzZXRBcnJbaV0ucHVzaChjdXJyZW50RHMuc2VyaWVzW2pdLmRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gR2V0dGluZyBncm93dGggYW5hbHlzZXIgb2JqZWN0IGZyb20gZGF0YXNldCBhcnJheVxuICAgICAgZm9yIChpID0gMCwgaWkgPSBhbGxEYXRhc2V0QXJyLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgZ3Jvd3RoQW5hbHlzZXJBcnIucHVzaChuZXcgR3Jvd3RoQW5hbHlzZXIoYWxsRGF0YXNldEFycltpXSkpO1xuICAgICAgfVxuICAgICAgLy8gU2F2aW5nIHJldHJpZXZlZCBncm93dGggYW5hbHlzZXIgYXJyYXkgdG8gaW5zdGFuY2VcbiAgICAgIGluc3RhbmNlLnRzT2JqZWN0Lmdyb3d0aEFuYWx5c2VyQXJyID0gZ3Jvd3RoQW5hbHlzZXJBcnI7XG4gICAgICAvLyBzYXZpbmcgZGF0YXNldCB0byBpbnN0YW5jZVxuICAgICAgaW5zdGFuY2UudHNPYmplY3QuZGF0YVN0b3JlID0gc3RvcmVEYXRhc2V0cztcbiAgICAgIHdpbmRvdy5nID0gcGFyYW1zLmdsb2JhbFJlYWN0aXZlTW9kZWw7XG4gICAgfVxuICAgIHdpbmRvdy5hID0gdGhpcztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBMZWdlbmRFeHQucHJvdG90eXBlLnJlbmRlckNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2hhcnRJbnN0YW5jZSA9IHRoaXMudHNPYmplY3QuY2hhcnRJbnN0YW5jZSxcbiAgICAgIGNvbXBvbmVudFN0b3JlID0gY2hhcnRJbnN0YW5jZS5hcGlJbnN0YW5jZS5nZXRDb21wb25lbnRTdG9yZSgpLFxuICAgICAgaSA9IDA7XG4gICAgZm9yIChpID0gMDsgY29tcG9uZW50U3RvcmUuZ2V0Q2FudmFzQnlJbmRleChpKTsgKytpKSB7XG4gICAgICBjb21wb25lbnRTdG9yZS5nZXRDYW52YXNCeUluZGV4KGkpLmdldENvbXBvc2l0aW9uKCkuUGxvdE1hbmFnZXIucGxvdCgpO1xuICAgIH1cbiAgfTtcblxuICBMZWdlbmRFeHQucHJvdG90eXBlLmFuYWx5c2VyID0gZnVuY3Rpb24gKG1vZGUpIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgICBpaSA9IDAsXG4gICAgICBqID0gMCxcbiAgICAgIGpqID0gMCxcbiAgICAgIGRhdGFTdG9yZSA9IHRoaXMudHNPYmplY3QuZGF0YVN0b3JlLFxuICAgICAgZ2FBcnIgPSB0aGlzLnRzT2JqZWN0Lmdyb3d0aEFuYWx5c2VyQXJyLFxuICAgICAgZ2FPYiA9IHt9O1xuICAgIGZvciAoaSA9IDAsIGlpID0gZ2FBcnIubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgZ2FPYiA9IGdhQXJyW2ldLmFuYWx5c2UobW9kZSk7XG4gICAgICBmb3IgKGogPSAwLCBqaiA9IGdhT2IubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICBkYXRhU3RvcmVbaV0uc2VyaWVzW2pdLmRhdGEgPSBnYU9iW2pdO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW5kZXJpbmcgdGhlIGNoYW5nZVxuICAgIHRoaXMucmVuZGVyQ2hhbmdlKCk7XG4gIH07XG5cbiAgTGVnZW5kRXh0LnByb3RvdHlwZS5nZXRMb2dpY2FsU3BhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiA3MCxcbiAgICAgIGhlaWdodDogMzBcbiAgICB9O1xuICB9O1xuXG4gIExlZ2VuZEV4dC5wcm90b3R5cGUucGxhY2VJbkNhbnZhcyA9IGZ1bmN0aW9uIChjb250YWluZXJJbnN0YW5jZSkge1xuICAgIHZhciBsb2dpY2FsU3BhY2UgPSB0aGlzLmdldExvZ2ljYWxTcGFjZSgpO1xuXG4gICAgY29udGFpbmVySW5zdGFuY2UuYWRkQ29tcG9uZW50KFt7XG4gICAgICBwSW5kZXg6IDMsXG4gICAgICB0eXBlOiAnSG9yaXpvbnRhbFN3aW1MYW5lJyxcbiAgICAgIGNvbXBvbmVudHM6IFt7XG4gICAgICAgIHR5cGU6ICdWZXJ0aWNhbFN3aW1MYW5lJyxcbiAgICAgICAgY29tcG9uZW50czogW3tcbiAgICAgICAgICB3aWR0aDogbG9naWNhbFNwYWNlLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogbG9naWNhbFNwYWNlLmhlaWdodCxcbiAgICAgICAgICBuYW1lOiAnTGVnZW5kRXh0JyxcbiAgICAgICAgICB4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoJ3gnLCAnQ2FudmFzMEdyb3VwJykgKyB0aGlzLmdldCgnd2lkdGgnLCAnQ2FudmFzMEdyb3VwJykgLyAyIC0gbG9naWNhbFNwYWNlLndpZHRoO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdHlwZTogJ01vZHVsZXMnLFxuICAgICAgICAgIHJlZjogdGhpc1xuICAgICAgICB9XVxuICAgICAgfV1cbiAgICB9XSwgMCk7XG4gIH07XG5cbiAgTGVnZW5kRXh0LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnRzT2JqZWN0LmdyYXBoaWNzLnBhcGVyLnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gIH07XG5cbiAgTGVnZW5kRXh0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG4gIH07XG5cbiAgRnVzaW9uQ2hhcnRzLnJlZ2lzdGVyQ29tcG9uZW50KCdleHRlbnNpb25zJywgJ2xlZ2VuZEV4dCcsIExlZ2VuZEV4dCk7XG59XSk7XG5cbid1c2Ugc3RyaWN0JztcbmNsYXNzIEdyb3d0aEFuYWx5c2VyIHtcbiAgY29uc3RydWN0b3IgKGRhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG4gIGFuYWx5c2UgKG1vZGUpIHtcbiAgICBsZXQgaSA9IDAsXG4gICAgICBpaSA9IDAsXG4gICAgICBqID0gMCxcbiAgICAgIGpqID0gMCxcbiAgICAgIG51bSA9IDAsXG4gICAgICBjaGVja0FyciA9IFtdLFxuICAgICAgY2hlY2tOdW0gPSAwLFxuICAgICAgZGF0YUFyID0gdGhpcy5kYXRhLFxuICAgICAgbkRhdGFBciA9IFtdLFxuICAgICAgdGVtcEFyID0gW107XG5cbiAgICBpZiAoIWlzTmFOKG1vZGUpKSB7IC8vIEhhbmRsaW5nIGEgbnVtYmVyXG4gICAgICBjaGVja051bSA9IG1vZGU7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGRhdGFBci5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHRlbXBBciA9IFtdO1xuICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGRhdGFBcltpXS5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgbnVtID0gZGF0YUFyW2ldW2pdO1xuICAgICAgICAgIHRlbXBBci5wdXNoKDEwMCAqIChudW0gLSBjaGVja051bSkgLyBjaGVja051bSk7XG4gICAgICAgIH1cbiAgICAgICAgbkRhdGFBci5wdXNoKHRlbXBBcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBkYXRhQXIubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB0ZW1wQXIgPSBbXTtcbiAgICAgICAgY2hlY2tOdW0gPSBtb2RlKGRhdGFBcltpXSk7XG4gICAgICAgIGZvciAoaiA9IDAsIGpqID0gZGF0YUFyW2ldLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBudW0gPSBkYXRhQXJbaV1bal07XG4gICAgICAgICAgdGVtcEFyLnB1c2goMTAwICogKG51bSAtIGNoZWNrTnVtKSAvIGNoZWNrTnVtKTtcbiAgICAgICAgfVxuICAgICAgICBuRGF0YUFyLnB1c2godGVtcEFyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc05hTihtb2RlLnJlbHBvc2l0aW9uKSkge1xuICAgICAgbW9kZSA9IG1vZGUucmVscG9zaXRpb247XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGRhdGFBci5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHRlbXBBciA9IFtdO1xuICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGRhdGFBcltpXS5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgbnVtID0gZGF0YUFyW2ldW2pdO1xuICAgICAgICAgIGlmIChqICsgbW9kZSA+PSAwICYmIGogKyBtb2RlIDwgamopIHtcbiAgICAgICAgICAgIGNoZWNrTnVtID0gZGF0YUFyW2ldW2ogKyBtb2RlXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tOdW0gPSBudW07XG4gICAgICAgICAgfVxuICAgICAgICAgIHRlbXBBci5wdXNoKDEwMCAqIChudW0gLSBjaGVja051bSkgLyBjaGVja051bSk7XG4gICAgICAgIH1cbiAgICAgICAgbkRhdGFBci5wdXNoKHRlbXBBcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNOYU4obW9kZS5wb3NpdGlvbikpIHtcbiAgICAgIG1vZGUgPSBtb2RlLnBvc2l0aW9uO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBkYXRhQXIubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB0ZW1wQXIgPSBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgamogPSBkYXRhQXJbaV0ubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICAgIG51bSA9IGRhdGFBcltpXVtqXTtcbiAgICAgICAgICBpZiAobW9kZSA+PSAwICYmIG1vZGUgPCBqaikge1xuICAgICAgICAgICAgY2hlY2tOdW0gPSBkYXRhQXJbaV1bbW9kZV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrTnVtID0gbnVtO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZW1wQXIucHVzaCgxMDAgKiAobnVtIC0gY2hlY2tOdW0pIC8gY2hlY2tOdW0pO1xuICAgICAgICB9XG4gICAgICAgIG5EYXRhQXIucHVzaCh0ZW1wQXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzTmFOKG1vZGUucmVsZGF0YXNldHBvc2l0aW9uKSkge1xuICAgICAgbW9kZSA9IG1vZGUucmVsZGF0YXNldHBvc2l0aW9uO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBkYXRhQXIubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB0ZW1wQXIgPSBbXTtcbiAgICAgICAgaWYgKGkgKyBtb2RlID49IDAgJiYgaSArIG1vZGUgPCBpaSkge1xuICAgICAgICAgIGNoZWNrQXJyID0gZGF0YUFyW2kgKyBtb2RlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGVja0FyciA9IGRhdGFBcltpXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGRhdGFBcltpXS5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgY2hlY2tOdW0gPSBjaGVja0FycltqXTtcbiAgICAgICAgICBudW0gPSBkYXRhQXJbaV1bal07XG4gICAgICAgICAgdGVtcEFyLnB1c2goMTAwICogKG51bSAtIGNoZWNrTnVtKSAvIG51bSk7XG4gICAgICAgIH1cbiAgICAgICAgbkRhdGFBci5wdXNoKHRlbXBBcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuRGF0YUFyO1xuICB9XG59XG59KHRoaXMsIGRvY3VtZW50KSk7XG4iXSwiZmlsZSI6ImNhbnZhc2xpdGUtZXM2Lm1pbi5qcyJ9
